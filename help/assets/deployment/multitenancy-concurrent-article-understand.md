---
title: 理解多租户与并发开发
seo-title: 理解多租户与并发开发
description: 'null'
seo-description: 'null'
uuid: 682093fe-ce55-4ef8-af10-99f7062f8b1b
discoiquuid: 0dfcdf39-7423-459f-8f35-ee5b4b829f2c
feature: connected-assets
topics: authoring, operations, sharing, publishing
audience: all
doc-type: article
activity: understand
version: 6.5
translation-type: tm+mt
source-git-commit: 99f2a8cdfe0b4f5f6f1a149d96affd2a9e8bcf75
workflow-type: tm+mt
source-wordcount: '2009'
ht-degree: 0%

---


# 理解多租户与并发开发 {#understanding-multitenancy-and-concurrent-development}

## 简介 {#introduction}

当多个团队将代码部署到同一AEM环境时，他们应遵循一些实践，以确保团队可以尽可能独立地工作，而不必与其他团队合作。 尽管这些技术永远无法完全消除，但这些技术将最大限度地减少跨团队依赖关系。 要想成功实现并发开发模型，开发团队之间的良好沟通至关重要。

此外，当多个开发团队在同一AEM环境工作时，可能会有一定程度的多租户安排。 关于试图在AEM环境中支持多个租户的实际考虑，特别是管理治理、运营和发展时所面临的挑战，已有很多文章。 本白皮书探讨了在多租户环境中实施AEM的一些技术难题，但这些建议中的许多将适用于具有多个开发团队的任何组织。

必须事先指出，尽管AEM可以支持在单个环境上部署多个站点甚至多个品牌，但并不优惠真正的多租赁。 某些环境配置和系统资源将始终在环境上部署的所有站点之间共享。 本白皮书提供指导，以尽量减少这些共享资源和优惠建议的影响，以简化这些领域的沟通和协作。

## 优势和挑战 {#benefits-and-challenges}

实施多租户环境面临许多挑战。

这些 Cookie 包括：

* 额外的技术复杂性
* 增加的开发开销
* 共享资源的跨组织依赖关系
* 操作复杂性增加

尽管面临诸多挑战，运行多租户应用程序确实具有以下优势：

* 降低硬件成本
* 缩短未来站点的上市时间
* 降低未来租户的实施成本
* 整个企业的标准架构和开发实践
* 通用代码库

如果企业需要真正的多租户，而对其他租户一无所知，且没有共享代码、内容或共同作者，那么单独的作者实例是唯一可行的选择。 应将开发工作的总体增加与基础架构和许可证成本的节省进行比较，以确定此方法是否最适合。

## 开发技术 {#development-techniques}

### 管理依赖项 {#managing-dependencies}

管理Maven项目依赖项时，所有团队在服务器上使用相同版本的给定OSGi捆绑包非常重要。 为了说明Maven项目管理不当时可能出问题的原因，我们举了一个例子：

项目A取决于库的版本1.0, foo;foo版本1.0已嵌入到服务器部署中。 项目B取决于库的版本1.1, foo;foo版本1.1已嵌入到其部署中。

此外，我们假定此库中的API在版本1.0和1.1之间发生了更改。此时，这两个项目中的一个将不再正常工作。

为了解决这一问题，我们建议将所有Maven项目都设为一个父级反应堆项目的子级。 该反应堆项目有两个用途：它允许根据需要一起构建和部署所有项目，并且包含所有子项目的依赖关系声明。 父项目定义依赖项及其版本，而子项目只声明它们所需的依赖项，从父项目继承版本。

在此情况下，如果处理项目B的团队需要foo版本1.1中的功能，则此更改将很快在开发环境中变得明显，即会中断项目A。此时，团队可以讨论此更改，使项目A与新版本兼容，或为项目B寻找替代解决方案。

请注意，这并不会消除这些团队共享这种依赖关系的必要性，它只是快速、及早地突出问题，以便团队可以讨论任何风险并商定解决方案。

### 防止代码重复 {#preventing-code-duplication-nbsp-br}

处理多个项目时，务必确保代码不重复。 代码复制增加了出现缺陷的可能性、系统更改的成本以及代码库中的整体刚性。 要防止重复，请将通用逻辑重构为可跨多个项目使用的可重用库。

为了支持这一需要，我们建议开发和维护一个所有小组都可以依赖和贡献的核心项目。 在这样做时，必须确保这个核心项目不再取决于各个团队的任何项目；这允许独立的可部署性，同时仍在促进代码重用。

核心模块中常见的代码示例包括：

* 系统范围的配置，如：
   * OSGi配置
   * Servlet过滤器
   * 资源解析器映射
   * 吊具变压器管线
   * 错误处理程序(或使用ACS AEM Commons错误页面处理程序1)
   * 授权Servlet用于权限敏感型缓存
* 实用程序类
* 核心业务逻辑
* 第三方集成逻辑
* 创作UI叠加
* 创作所需的其他自定义设置，如自定义构件
* 工作流启动器
* 跨站点使用的常见设计元素

*模块化项目架构*

这并不消除多个团队依赖和可能更新同一组代码的需求。 通过创建一个核心项目，我们减少了团队之间共享的代码库的大小，但并未消除对共享资源的需求。

为确保对此核心软件包所做的更改不会破坏系统的功能，我们建议由高级开发人员或开发人员团队进行监督。 一种选择是，由一个团队管理对此包所做的所有更改；另一种方法是让团队提交由这些资源审查和合并的拉入请求。 必须由团队设计并同意一种治理模型，并且开发人员要遵循它。

## 管理部署范围(&amp;N) {#managing-deployment-scope}

由于不同的团队将其代码部署到同一存储库，因此，不要覆盖彼此的更改，这一点很重要。 AEM在部署内容包（过滤器）时具有控制这种情况的机制。 xml文件。 筛选器之间不存在重叠这一点很重要。  xml文件，否则一个团队的部署可能会擦除另一个团队以前的部署。 为说明这一点，请参见精心制作的与有问题的筛选器文件的以下示例：

/apps/my-公司与/apps/my-公司/my-site

/etc/clientlibs/my-公司与/etc/clientlibs/my-公司/my-site

/etc/designs/my-公司与/etc/designs/my-公司/my-site

如果每个团队将其筛选器文件明确配置到他们正在处理的站点，则每个团队可以独立部署其组件、客户端库和站点设计，而不会删除彼此的更改。

由于它是全局系统路径，并非特定于一个站点，因此核心项目中应包含以下servlet，因为此处所做的更改可能会潜在地影响任何团队：

/apps/sling/servlet/errorhandler

### 叠加 {#overlays}

叠加通常用于扩展或替换开箱即用的AEM功能，但使用叠加会影响整个AEM应用程序（即，所有租户都可以更改任何功能）。 如果租户对叠加有不同的要求，这将更加复杂。 理想情况下，业务组应共同商定AEM管理控制台的功能和外观。

如果各业务部门无法达成共识，可能的解决方案就是不使用叠加。 而是创建功能的自定义副本，并为每个租户通过不同的路径显示它。 这允许每个租户具有完全不同的用户体验，但这种方法也增加了实施和后续升级工作的成本。

### 工作流启动器 {#workflow-launchers}

AEM使用工作流启动器在存储库中进行指定更改时自动触发工作流执行。 AEM提供了多个开箱即用的启动程序，例如，对新资产和更新资产执行再现生成和元数据提取流程。 虽然可以按原样保留这些启动器，但在多租户环境中，如果租户有不同的启动器和／或工作流模型要求，则可能需要为每个租户创建和维护单个启动器。 这些启动器需要配置为执行其租户的更新，同时保留其他租户的内容。 轻松完成此操作的方法是将启动器应用到特定于租户的指定存储库路径。

### 虚 URL{#vanity-urls}

AEM提供虚URL功能，可以按页设置。 在多租户情况下，此方法的问题在于AEM不确保以这种方式配置的虚URL之间的唯一性。 如果两个不同的用户为不同的页面配置了相同的虚路径，则会遇到意外行为。 因此，我们建议在Apache调度程序实例中使用mod_rewrite规则，它允许与仅出站资源解析程序规则一起提供一个配置中心点。

### 组件组 {#component-groups}

为多个创作组开发组件和模板时，请务必有效使用componentGroup和allowedPaths属性。 通过将这些功能有效地用于网站设计，我们可以确保品牌A的作者只能查看为其网站创建的组件和模板，而品牌B的作者只能查看他们的组件和模板。

### 测试 {#testing}

良好的架构和开放式通信渠道有助于防止在网站的意外区域引入缺陷，但这些方法并非万无一失。 因此，在将任何内容投入生产之前，必须全面测试平台上部署的内容。 这需要团队在发布周期中进行协调，并且需要一套覆盖所有功能的自动化测试。 此外，由于一个系统将由多个团队共享，性能、安全性和负载测试变得比以往更加重要。

## 操作注意事项 {#operational-considerations}

### 共享资源 {#shared-resources}

AEM在单个JVM中运行；所有部署的AEM应用程序都以AEM正常运行中已消耗的资源为基础相互共享资源。 在JVM空间本身中，线程不会逻辑分离，AEM可用的有限资源（如内存、CPU和磁盘i/o）也将共享。 任何租户消耗资源都不可避免地会影响其他系统租户。

### 演出 {#performance}

如果不遵循AEM最佳做法，则有可能开发占用超出正常范围的资源的应用程序。 此操作的示例包括触发许多繁重的工作流操作（如DAM更新资产）、在多个节点上使用MSM推送——修改操作，或使用昂贵的JCR查询实时呈现内容。 这些将不可避免地对其他租户应用程序的性能产生影响。

### 记录 {#logging}

AEM为强大的记录器配置提供了开箱即用的界面，可用于我们在共享开发场景中的优势。 通过为每个品牌指定单独的日志记录器，通过包名称，可以实现一定程度的日志分离。 虽然复制和身份验证等系统范围的操作仍将记录到一个中心位置，但非共享的自定义代码可以单独记录，简化了每个品牌技术团队的监控和调试工作。

### 备份和恢复 {#backup-and-restore}

由于JCR存储库的性质，传统备份可以跨整个存储库工作，而不是在单个内容路径上工作。 因此，无法根据每个租户轻松分离备份。 相反，从备份中恢复将回滚系统上所有租户的内容和存储库节点。 虽然可以使用VLT等工具执行目标内容备份，或者通过在单独的环境中构建包来挑选要恢复的内容，但这些\
方法不容易包含配置设置或应用程序逻辑，而且管理起来很麻烦。

## 安全注意事项 {#security-considerations}

### ACL {#acls}

当然，可以使用访问控制列表(ACL)来控制谁有权访问视图、创建和删除基于内容路径的内容，这需要创建和管理用户组。 维护ACL和组的困难取决于如何确保每个租户对其他租户一无所知，以及部署的应用程序是否依赖共享资源。 为了确保高效的ACL、用户和组管理，我们建议建立一个集中的组，进行必要的监督，以确保这些访问控制和承担者以一种能够提高效率和安全性的方式重叠（或不重叠）。
