---
title: 第3章——高级缓存主题
seo-title: AEM调度程序缓存需求——第3章——高级缓存主题
description: AEM Dispatcher Cache演示教程的第3章介绍如何克服第2章中讨论的限制。
seo-description: AEM Dispatcher Cache演示教程的第3章介绍如何克服第2章中讨论的限制。
translation-type: tm+mt
source-git-commit: a0e5a99408237c367ea075762ffeb3b9e9a5d8eb
workflow-type: tm+mt
source-wordcount: '6187'
ht-degree: 0%

---


# 第3章——高级缓存主题

*“在计算机科学中，只有两个难点：缓存失效和命名事项。”*

—菲尔·卡尔顿

## 概述

这是三部分的第3部分——系列在AEM中缓存。 前两个部分侧重于调度程序中的纯http缓存，以及存在哪些限制。 本部分讨论如何克服这些限制。

## 一般缓存

[本系列第](chapter-1.md) 1章 [和第](chapter-2.md) 2章主要针对调度程序。 我们已解释了基础知识、限制以及您需要在何处进行某些取舍。

缓存复杂性和复杂性并非调度程序特有的问题。 通常，缓存很困难。

将Dispatcher作为工具箱中唯一的工具，实际上是一个真正的限制。

在本章中，我们希望进一步扩展缓存方面的视图，并开发一些思路，帮助您克服Dispatcher的一些缺点。 没有万灵丹——您必须在项目中做出权衡。 记住，缓存和失效准确性总是会带来复杂性，而复杂性会带来错误。

你需要在这些领域进行权衡，

* 性能和延迟
* 资源消耗/CPU负载／磁盘使用
* 准确性／货币／稳定性／安全性
* 简单性／复杂性／成本／可维护性／容易出错

这些维度在一个相当复杂的系统中相互关联。 没有简单的如果，那。 使系统更简单可以使它更快或更慢。 它可以降低您的开发成本，但会增加服务台的成本，例如，如果客户看到陈腐的内容或抱怨网站运行缓慢。 所有这些因素都需要相互考虑和平衡。 但现在，你应该已经有了一个好主意，那就是没有银弹，也没有单一的“最佳实践”—只有许多不佳的实践和一些好的实践。

## 链式缓存

### 概述

#### 数据流

将页面从服务器传送到客户机的浏览器跨越多个系统和子系统。 如果仔细查看，需要从源到漏的数据有许多跳数，每个跳数都是缓存的潜在候选。

![典型CMS应用程序的数据流](assets/chapter-3/data-flow-typical-cms-app.png)

*典型CMS应用程序的数据流*

<br> 

让我们用一块位于硬盘上、需要在浏览器中显示的数据来开始我们的旅程。

#### 硬件和操作系统

首先，硬盘(HDD)本身在硬件中有一些内置的缓存。 其次，装载硬盘的操作系统使用空闲内存缓存经常访问的块以加速访问。

#### 内容存储库

下一级是CRX或Oak —AEM使用的文档数据库。 CRX和Oak将数据分为可在内存中缓存的区段，以避免对硬盘的访问速度变慢。

#### 第三方数据

大多数较大的Web安装也具有第三方数据；来自产品信息系统、客户关系管理系统、传统数据库或任何其它任意web服务的数据。 无需在任何需要时从源中提取此数据——尤其不需要，在知道更改不太频繁时。 因此，如果它未在CRX数据库中同步，则可以缓存它。

#### 业务层——应用／模型

通常，模板脚本不会通过JCR API呈现来自CRX的原始内容。 您很可能在业务层之间进行合并、计算和／或转换业务域对象中的数据。 猜猜怎么着——如果这些操作费用高昂，您应该考虑缓存它们。

#### 标记片段

模型现在是组件标记渲染的基础。 为什么不同时缓存渲染的模型？

#### 调度程序、CDN和其他代理

关闭会将呈现的HTML页转至调度程序。 我们已经讨论过，调度程序的主要用途是缓存HTML页面和其他Web资源（尽管有其名称）。 在资源到达浏览器之前，它可能会传递反向代理（可缓存）和CDN（也用于缓存）。 客户端可能位于办公室中，仅通过代理授予Web访问权限，而代理可能决定缓存并保存流量。

#### 浏览器缓存

最后，但也不是最不重要的是，浏览器也缓存了。 这是一项容易忽视的资产。 但它是缓存链中最接近、最快的缓存。 很遗憾，它不在用户之间共享，但仍在一个用户的不同请求之间共享。

### 缓存位置及原因

这是一长串潜在的缓存。 我们都面临着内容过时的问题。 但考虑到这有多少个阶段，它大部分时间都在工作，这是个奇迹。

但是，在这条链中，缓存有什么意义呢？ 刚开始？ 最后？ 随处？ 这取决于……它取决于很多因素。 即使同一网站中有两个资源也可能希望对该问题给出不同的答案。

大致了解您可能考虑哪些因素，

**生存时间** -如果对象具有短的固有生存时间（交通数据的生存时间可能比天气数据短），则可能不值得缓存。

**生产成本** -对象的再生产和投放（以CPU周期和I/O计算）是多贵。 如果它便宜的缓存，可能就不必了。

**大小** -大型对象需要更多资源才能缓存。 这可能是一个限制因素，必须与利益相平衡。

**访问频率** -如果对象很少访问，缓存可能无效。 它们只会失效或失效，然后才能第二次从缓存访问。 这些项目只会阻止内存资源。

**共享访问** -应在链的更上方对多个实体使用的数据进行缓存。 事实上，缓存链不是链，而是树。 存储库中的一条数据可能被多个模型使用。 这些模型反过来又可以由多个渲染脚本使用以生成HTML片段。 这些片段包含在多个页面中，这些页面在浏览器中以其专用缓存分发给多个用户。 因此，“共享”并不意味着只在人与人之间共享，而是在软件之间共享。 如果要查找潜在的“共享”缓存，只需跟踪树到根并查找共同的祖先，即可缓存。

**地理空间分** 布——如果您的用户分布于全球，使用分布式缓存网络可能有助于减少延迟。

**网络带宽和延迟** -说到延迟，您的客户是谁，他们使用的是哪种网络？ 也许您的客户是使用老一代智能手机3G连接的发达国家的移动客户？ 请考虑创建较小的对象并将其缓存到浏览器缓存中。

这个列表到目前为止还不够全面，但我们认为您现在已经有了这个想法。

### 链式缓存的基本规则

同样，缓存很困难。 让我们分享一些基本规则，这些规则是我们从以前的项目中提取的，可帮助您避免项目中出现的问题。

#### 避免多次缓存

在最后一章中介绍的每个图层都在缓存链中提供一些值。 或者通过节省计算周期，或者让数据更接近消费者。 将数据缓存到链的多个阶段并不错——但您应始终考虑下一个阶段的好处和成本。 在发布系统中缓存完整页面通常不提供任何好处——这在调度程序中已经实现。

#### 混合失效策略

有三种基本的失效策略：

* **TTL，生存时间：** 对象在固定的时间后过期（例如“2小时后”）
* **过期日期：** 对象在将来的定义时间过期（例如，“2019年6月10日下午5:00”）
* **事件:** 该对象由平台中发生的事件（例如，当页面被更改和激活时）显式失效

现在，您可以在不同的缓存层上使用不同的策略，但有一些“有毒”策略。

#### 事件失效

![纯事件失效](assets/chapter-3/event-based-invalidation.png)

*纯事件失效：从内部缓存到外层失效*

<br> 

纯事件失效是最容易理解的失效，理论上最容易理解的失效，也是最准确的失效。

简单地说，在对象发生更改后，缓存将逐个失效。

您只需牢记一条规则：

始终从内到外缓存失效。 如果先使外部缓存失效，它可能会从内部缓存中重新缓存过时内容。 不要在什么时候再次刷新缓存时做出任何假设——请确保。 最好，在内缓存失效后触发外 _缓存_ 的失效。

这就是理论。 但实际上，还有很多错误。 事件必须通过网络进行分发。 在实际中，这使其成为最难实现的失效方案。

#### 自动——修复

在基于事件的失效情况下，您应制定应急计划。 如果错过了失效事件怎么办？ 一个简单的策略是在一定时间后失效或清除。 因此，您可能错过了事件，现在提供陈腐的内容。 但是，对象的隐式TTL仅为几小时（天）。 最终系统自动修复。

#### 纯基于TTL的失效

![基于未同步TTL的失效](assets/chapter-3/ttl-based-invalidation.png)

*基于未同步TTL的失效*

<br> 

那个也是一个很普遍的方案。 您堆叠多层缓存，每个缓存都有权为某个对象提供特定时间。

易于实施。 不幸的是，很难预测某个数据的有效寿命。

![延长内物体寿命的外壳](assets/chapter-3/outer-cache.png)

*延长内部对象寿命的外部高速缓存*

<br> 

请考虑上述插图。 每个缓存层引入2分钟的TTL。 现在——总TTL也必须2分钟，对吗？ 不是。 如果外层在对象失效前即获取该对象，则外层实际延长该对象的有效生存时间。 在这种情况下，有效的实时时间可以在2到4分钟之间。 考虑到你与业务部门达成了一致，有一天是可以容忍的——而你有四层缓存。 每个层上的实际TTL不得长于6小时……增加缓存脱机率……

我们并不是说这是一个坏计划。 你应该知道它的局限性。 这是一个很好且易于开始的策略。 只有在网站流量增加时，您才能考虑更准确的策略。

*通过设置特定日期来同步失效时间*

#### 基于过期日期的失效

如果要在内部对象上设置特定日期并将其传播到外部高速缓存，则会获得更可预测的有效寿命。

![同步过期日期](assets/chapter-3/synchronize-expiration-dates.png)

*同步过期日期*

<br> 

但是，并非所有缓存都能传播日期。 当外部缓存聚合两个具有不同过期日期的内部对象时，它会变得很讨厌。

#### 基于混合事件和基于TTL的失效

![基于事件和TTL的混合策略](assets/chapter-3/mixing-event-ttl-strategies.png)

*基于事件和TTL的混合策略*

<br> 

AEM世界中的一个常见方案是在内部缓存(例如，内存中缓存可以近乎实时地处理事件)和外部基于TTL的缓存中使用基于事件的失效，在内存中缓存中，您可能无权访问显式失效。

在AEM环境中，您将在发布系统中为业务对象和HTML片段提供内存中的缓存，当基础资源发生更改并将此更改事件传播到调度程序时，该缓存将失效，调度程序也基于事件工作。 在此之前，您会拥有基于TTL的CDN。

在调度程序之前拥有一个（短）基于TTL的缓存层可以有效地软化通常在自动失效后会发生的尖峰。

#### 混合TTL和基于事件的失效

![混合TTL和基于事件的失效](assets/chapter-3/toxic.png)

*有毒：混合TTL和基于事件的失效*

<br> 

这种组合是有毒的。 在基于TTL或Expiry的缓存后，切勿放置基于事件的缓存。 还记得“纯TTL”策略中的溢流效应吗？ 这里可以观察到相同的效果。 只有外部缓存的失效事件已发生，才可能再次发生——这会将缓存对象的寿命扩展到无限。

![基于TTL和基于事件的组合：溢出到无限](assets/chapter-3/infinity.png)

*基于TTL和基于事件的组合：溢出到无限*

<br> 

## 部分缓存和内存中缓存

您可以挂接到渲染过程的舞台，以添加缓存层。 从获取远程数据传输对象或创建本地业务对象到缓存单个组件的渲染标记。 我们将在稍后的教程中介绍具体的实施。 但是，您可能已经计划自己实施其中的一些缓存层。 因此，我们至少可以在此介绍基本原则——以及成果。

### 警告词

#### 尊重访问控制

此处介绍的技术非常强大，每个AEM _开发人员的_ “工具箱”中都包含这些技术。 但别太激动，明智地使用它们。 通过将对象存储在缓存中并在后续请求中将其共享给其他用户，实际上意味着规避访问控制。 这通常在面向公众的网站上不是问题，但可能是，当用户需要登录才能访问时。

考虑将站点主菜单的HTML标记存储在内存中的缓存中，以便在不同页面之间共享它。 实际上，这是存储部分呈现的HTML作为创建导航的一个完美示例，通常很昂贵，因为它需要遍历大量页面。

您不是在所有页面之间共享同一菜单结构，而是与所有用户共享，这样更加有效。 但是，等等……但是菜单中可能有些项目只为特定用户组保留。 在这种情况下，缓存可能会变得更加复杂。

#### 仅缓存自定义业务对象

如果有的话——这是最重要的建议，我们可以给您：

>[!WARNING]
>
>仅缓存您自己构建的、浅的、没有传出引用的不可改变的您的对象。

这是什么意思？

1. 你不知道其他人物的预定生命周期。 请考虑您看到对请求对象的引用并决定将其缓存。 现在，请求已结束，Servlet容器希望为下一个传入请求重复使用该对象。 在这种情况下，其他人正在更改您认为您拥有专属控制权的内容。 别对此嗤之以鼻——我们在一个项目中看到了类似的情况。 客户看到的是其他客户数据，而不是自己的数据。

2. 只要对象被其他引用的链引用，就不能将其从堆中删除。 如果您在缓存中保留一个引用的本应较小的对象，假设图像的4MB表示形式很可能会导致内存泄漏。 缓存应基于弱引用。 但是，弱引用并不像您预期的那样有效。 这是产生内存泄漏并导致内存不足错误的绝对最佳方法。 而且——你不知道外来物体保留内存的大小，对吗？

3. 尤其是在Sling中，您可以（几乎）将每个对象相互调整。 考虑将资源放入缓存。 下一个请求（具有不同的访问权限）会获取该资源并将其调整为resourceResolver或会话以访问他无权访问的其他资源。

4. 即使您在AEM的资源周围创建一个精简的“包装器”，您也不能缓存该资源——即使它是您自己的、不可改变的。 包装的对象将是引用（我们以前禁止），如果我们看起来清晰，将产生与上一项中所述相同的问题。

5. 如果要缓存，请通过将基本数据复制到自己的共享对象中来创建您自己的对象。 您可能希望通过引用在您自己的对象之间链接——例如，您可能希望缓存对象树。 这是不错的，但仅缓存您刚刚在同一请求中创建的对象，而没有从其他位置请求的对象（即使它是“您的”对象的名称空间）。 _复制对象_ 是关键所在。 同时确保一次性清除链接对象的整个结构，并避免对结构的传入和传出引用。

6. 是——并保持对象不变。 私有属性，仅限，无设置者。

这是很多规则，但值得遵循。 即使你经验丰富，非常聪明，一切尽在掌握。 你项目中的年轻同事刚大学毕业。 他不知道这些陷阱。 如果没有陷阱，就没什么可避免的。 使其简单易懂。

### 工具和库

本系列旨在了解概念并使您能够构建最适合您使用案例的架构。

我们并不特别推荐任何工具。 但是，请给出如何评估它们的提示。 例如，AEM具有自6.0版以来固定TTL的简单内置缓存。是否使用它？ 可能不在发布链中基于事件的缓存跟随的位置(提示：调度程序)。 但对作者来说，这可能是一个不错的选择。 还有一个由AdobeACS共享的HTTP缓存，值得考虑。

或者，您也可以根据Ehcache等成熟的缓存框架构建自己 [的内容](https://www.ehcache.org)。 这可用于缓存Java对象和呈现的标记(对`String` 象)。

在一些简单的情况下，您还可以使用并发哈希映射，快速了解此处的限制——无论是在工具上还是在技能上。 并发与命名和缓存一样难以主控。

#### 引用

* [ACS公共HTTP缓存 ](https://adobe-consulting-services.github.io/acs-aem-commons/features/http-cache/index.html)
* [高速缓存框架](https://www.ehcache.org)

### 基本术语

我们不会太深入地研究缓存理论，但我们觉得有必要提供一些流言，这样您就有了很好的跳跃开始。

#### 缓存逐出

我们讨论过很多失效和清除。 _缓存驱逐_ 与以下条款相关：在条目被驱逐后，它不再可用。 但是，逐出不是在条目过时时，而是在缓存已满时。 较新或“更重要”的项目将较旧或不太重要的项目从缓存中推出。 你必须牺牲哪些条目是个个案决定。 您可能想要驱逐那些使用非常少或最后访问时间较长的用户或用户。

#### 抢先缓存

抢先缓存是指在条目失效或被认为过时时，使用新内容重新创建该条目。 当然，您只需使用一些资源即可完成此操作，您确实可以经常和立即访问这些资源。 否则，您将浪费资源创建可能从未请求的缓存条目。 通过预先创建缓存条目，可减少缓存失效后对资源的第一个请求的延迟。

#### 高速缓存预热

缓存预热与抢先缓存密切相关。 虽然你不会用这个术语来建立实时系统。 而且，与前者相比，它所受到的时间约束也更少。 失效后不立即重新缓存，但在时间允许时逐渐填充缓存。

例如，从负载平衡器中取出Publish / Dispatcher腿进行更新。 在重新集成之前，您会自动爬网最常访问的页面，以再次将它们放入缓存中。 当缓存“温暖”时——已充足，您将腿重新集成到负载平衡器中。

或者你可以立刻重新整合腿部，但是你把流量限制到腿部，这样它就有机会通过常规的使用来温暖它的缓存。

或者，您也希望在系统空闲时缓存一些访问频率较低的页面，以减少实际请求访问这些页面时的延迟。

#### 缓存对象标识、有效负荷、失效依赖关系和TTL

通常，缓存对象或“条目”有五个主要属性，

#### 键

这是标识，您通过它来标识和对象。 要检索其有效负荷，或从缓存中清除它。 例如，调度程序使用页面的URL作为键。 请注意，调度程序不使用页面路径。 这不足以区分不同的呈现方式。 其他缓存可能使用不同的键。 稍后我们将看一些例子。

#### 值／有效负荷

这是物体的宝库，你想要检索的数据。 如果是调度程序，则它是文件内容。 但它也可以是Java对象树。

#### TTL

我们已经覆盖了TTL。 在此时间之后，某个条目被视为过时，不应再传送。

#### 依赖关系

这涉及基于事件的失效。 该对象所依赖的原始数据是什么？ 在第一部分中，我们已经说过，真实、准确的依赖跟踪过于复杂。 但是，借助我们对系统的了解，您可以使用更简单的模型来近似依赖关系。 我们使足够多的对象失效，以清除过时的内容……并且可能无意中清除的内容超出要求。 但我们仍试图保持低于“清除一切”的水平。

在每个应用程序中，哪些物品取决于其他物品的正版。 我们稍后将给出一些如何实施依赖策略的示例。

### HTML片段缓存

![在不同页面上重新使用呈现的片段](assets/chapter-3/re-using-rendered-fragment.png)

*在不同页面上重新使用呈现的片段*

<br> 

HTML片段缓存是一个强大的工具。 其思想是将组件生成的HTML标记缓存在内存中缓存中。 你可能会问，我为什么要这么做？ 我仍将整个页面的标记缓存在调度程序中——包括该组件的标记。 我们同意。 确实如此，但每页只需一次。 您不会在页面之间共享该标记。

想象一下，您正在每页的顶部渲染导航。 标记在每个页面上的外观都相同。 但是，您会一遍又一遍地渲染每个页面，而不是在调度程序中。 记住：自动失效后，需要重新呈现所有页面。 因此，基本上，您运行相同的代码并且结果相同数百次。

从我们的经验来看，呈现嵌套的顶部导航是一个非常昂贵的任务。 通常，您遍历文档树的一大部分以生成导航项。 即使您只需要导航标题和URL —— 页面也必须加载到内存中。 而这里，它们正塞满宝贵的资源。 一遍又一遍。

但该组件在许多页面之间共享。 而共享内容则表示使用缓存。 因此，您希望执行的操作是检查导航组件是否已经渲染和缓存，而不是重新渲染只发出缓存值。

这个计划有两个美妙的细节很容易被忽略：

1. 您正在缓存Java字符串。 字符串没有任何传出引用，并且不可变。 因此，考虑到上述警告，这是超级安全的。

2. 失效也非常容易。 只要网站发生任何更改，您就希望使此缓存条目失效。 重建成本相对较低，因为只需执行一次，然后百页的内容都会重复使用。

这让您的发布服务器大放异彩。

### 片段缓存的实现

#### 自定义标记

在过去，将JSP用作模板引擎时，使用自定义JSP标签环绕组件呈现代码是很常见的。

```
<!-- Pseudo Code -->

<myapp:cache
  key=' ${info.homePagePath} + ${component.path}'
  cache='main-navigation'
  dependency='${info.homePagePath}'>

… original components code ..

</myapp:cache>
```

与捕获其正文并将其写入缓存或阻止执行其正文并输出缓存条目的有效负荷相比，该自定义标记。

“密钥”是它在主页上的组件路径。 我们不会在当前页面上使用组件的路径，因为这样会为每个页面创建一个缓存条目——这与我们共享该组件的意图相矛盾。 我们也不仅使用组件相对路径(`jcr:conten/mainnavigation`)，因为这会阻止我们在不同站点中使用不同的导航组件。

“缓存”是存储条目的指示器。 通常，在将项目存储到的位置有多个缓存。 每一个可能都有点不同。 因此，区分存储内容是好的——即使最终只是字符串。

“依赖关系”是缓存条目所依赖的。 “主导航”缓存可能有一条规则，即如果节点“依赖关系”下有任何更改，则必须清除根据条目。 因此，您的缓存实现需要将自身注册为存储库中的事件侦听器，以了解更改，然后应用缓存特定规则以找出哪些内容需要失效。

以上只是一个例子。 您还可以选择具有缓存树。 当第一层用于分离站点（或租户），而第二层用于分离内容类型（例如“主导航”）时，这样您就可以添加主页路径，如上例所示。

顺便说一下，您还可以将此方法用于更现代化的基于HTL的组件。 然后，您的HTL脚本中将有一个JSP包装器。

#### 组件过滤器

但是，在纯HTL方法中，您宁可使用Sling组件过滤器构建片段缓存。 我们还没有看到这个，但我们会采取这样的方法来处理这个问题。

#### Sling Dynamic Include

如果您在更改环境（不同页面）的上下文中有一些常量（导航），则使用片段缓存。

但您可能也有相反的内容，即相对恒定的上下文（很少更改的页面）和该页面上一些不断更改的片段（例如实时滚动条）。

在这种情况下，您可以给 [Sling Dynamic Includes](https://sling.apache.org/documentation/bundles/dynamic-includes.html) 一个机会。 本质上，这是一个组件过滤器，它绕排在动态组件周围，而不是将组件渲染到它创建引用的页面中。 此引用可以是Ajax调用——这样组件便被浏览器包含，因此周围的页面可以静态缓存。 或者，Sling Dynamic Include可以生成SSI指令（服务器端包括）。 此指令将在Apache服务器中执行。 如果您利用的是ISE或支持ESI脚本的CDN，您甚至可以使用ESI —— 边缘包含指令。

![使用Sling Dynamic Include的请求序列图](assets/chapter-3/sequence-diagram-sling-dynamic-include.png)

*使用Sling Dynamic Include的请求序列图*

<br> 

SDI文档说，您应当禁用以“*.nocache.html”结尾的URL的缓存，这很合理，因为您正在处理动态组件。

您可能会看到另一个如何使用SDI的选项：如果您 _不为_ includes禁用调度程序缓存，则调度程序的操作类似于我们在上一章中描述的片段缓存：页面和组件片段在调度程序中以平等和独立方式缓存，并在请求页面时由Apache服务器中的SSI脚本拼接在一起。 这样，您可以实现共享组件（如主导航）（假定您始终使用相同的组件URL）。

理论上，这应该奏效。 但是……

我们建议不要这样做：您将无法绕过实际动态组件的缓存。 SDI已进行全局配置，您对“穷手段——片段——缓存”所做的更改也将应用于动态组件。

我们建议您仔细研究SDI文档。 还有一些其他限制，但SDI在某些情况下是非常有价值的工具。

#### 引用

* [docs.oracle.com —— 如何编写自定义JSP标记](https://docs.oracle.com/cd/E11035_01/wls100/taglib/quickstart.html)
* [Dominik Süß —— 创建和使用组件过滤器](https://www.slideshare.net/connectwebex/prsentation-dominik-suess)
* [sling.apache.org - Sling Dynamic Includes](https://sling.apache.org/documentation/bundles/dynamic-includes.html)
* [helpx.adobe.com —— 在AEM中设置Sling Dynamic Includes](https://helpx.adobe.com/experience-manager/kt/platform-repository/using/sling-dynamic-include-technical-video-setup.html)


#### 模型缓存

![基于模型的缓存：一个业务对象，具有两个不同的呈现](assets/chapter-3/model-based-caching.png)

*基于模型的缓存：一个业务对象，具有两个不同的呈现*

<br> 

让我们再次通过导航重新查看案例。 我们假设，每个页面都需要相同的导航标记。

但也许，情况并非如此。 您可能希望在表示当前页面的导航中为项目呈现不同 _的标记_。

```
Travel Destinations

<ul class="maninnav">
  <li class="currentPage">Travel Destinations
    <ul>
      <li>Finland
      <li>Canada
      <li>Norway
    </ul>
  <li>News
  <li>About us
<ul>
```

```
News

<ul class="maninnav">
  <li>Travel Destinations
  <li class="currentPage">News
    <ul>
      <li>Winter is coming>
      <li>Calm down in the wild
    </ul>
  <li>About us
<is
```

这是两种完全不同的再现。 然而，商 _业对象_ —完整的导航树——却是一样的。  此 _处的业_ 务对象将是表示树中节点的对象图。 该图形可容易地存储在内存高速缓存中。 但请记住，此图形不得包含任何对象或引用您未自己创建的任何对象——尤其是现在的JCR节点。

#### 在浏览器中缓存

我们已经提到了在浏览器中缓存的重要性，并且有许多好的教程。 最后，对于浏览器，调度程序只是遵循HTTP协议的Web服务器。

然而，尽管有这种理论，但我们已经收集了一些我们没有发现、也想分享的知识。

本质上，浏览器缓存可以通过两种不同的方式进行利用，

1. 浏览器已缓存资源，其知道确切的到期日期。 在这种情况下，它不再请求资源。

2. 浏览器有资源，但不确定它是否仍然有效。 在这种情况下，它将询问Web服务器（本例中为调度程序）。 如果资源自您上次提交后已进行修改，请将其给我。 如果它没有更改，则服务器以“304 —— 未更改”回答，只传输元数据。

#### 调试

如果您正在优化Dispatcher设置以进行浏览器缓存，则在浏览器和Web服务器之间使用桌面代理服务器非常有用。 我们更喜欢卡尔·冯·兰多的“Charles Web Debugging Proxy”。

使用Charles，您可以读取在服务器之间或与服务器之间传输的请求和响应。 此外，您还可以了解有关HTTP协议的许多信息。 现代浏览器也优惠了一些调试功能，但桌面代理的功能是前所未有的。 您可以处理传输的数据、限制传输、重播单个请求等。 用户界面布局清晰、全面。

最基本的测试是将网站作为普通用户使用（代理介于中间），如果静态请求（到/etc/...）的数量随着时间的推移而减少，则检查代理，因为这些请求应该位于缓存中，而不再被请求。

我们发现，代理可能会给出更清晰的概述，因为缓存的请求不会显示在日志中，而某些浏览器内置的调试器仍以“0毫秒”或“从磁盘”显示这些请求。 这是正确的，但可能会让视图蒙上一层阴影。

然后，您可以展开并检查已传输文件的头，以查看(例如，如果“Expires”（过期）http头正确)。 您可以重播请求，将if-modified-since标头设置为查看服务器是否使用304或200响应代码正确响应。 您可以观察异步调用的时间，也可以在一定程度上测试您的安全假设。 请记住，我们告诉您不要接受所有未明确预期的选择器？ 在这里，您可以使用URL和参数来查看应用程序是否运行良好。

在调试缓存时，我们只要求您不要执行以下操作：

不要在浏览器中重新加载页面！

“浏览器重新加载” _、简单重_ 、强制重 _新加载_ (“_shift-reload_”)与普通页面请求不同。 简单的重新加载请求设置标题

```
Cache-Control: max-age=0
```

而Shift-Reload（在单击重新加载按钮时按住“Shift”键）通常会设置请求标头

```
Cache-Control: no-cache
```

两个标题的效果相似但略有不同，但最重要的是，当您从URL插槽打开URL或使用站点上的链接时，它们与普通请求完全不同。 正常浏览未设置Cache-Control头，但可能是if-modified-scine头。

因此，如果要调试正常的浏览行为，您应该正确执行以下操作： _正常浏览_。 使用浏览器的重新加载按钮是在配置中看不到缓存配置错误的最佳方式。

使用Charles Proxy查看我们在谈论什么。 是——当您打开请求时，您可以在此处重播请求。 无需从浏览器重新加载。

## 性能测试

通过使用代理，您可以了解页面的时间行为。 当然，这远不是性能测试。  性能测试需要多个客户端并行请求页面。

我们经常看到的一个常见错误是性能测试只包含非常少的页面，而这些页面仅从调度程序缓存中传送。

如果要将应用程序提升到实时系统，则负载与测试的负载完全不同。

在实时系统上，访问模式并不是测试中平均分布的页面数量少(主页和内容页面少)。 页数要大得多，请求的分布也很不均匀。 而且，当然，活动页面无法从缓存100%处理：来自发布系统的无效请求会自动使您宝贵资源的很大一部分失效。

是的——当您重建Dispatcher缓存时，您会发现，发布系统的工作方式也有很大不同，具体取决于您是仅请求少数几页，还是请求数量更大。 即使所有页面都同样复杂——页码也起着一定作用。 还记得我们说的链式缓存吗？ 如果您始终请求相同数量的页面，则很有可能，具有原始数据的相应块位于硬盘缓存中，或者这些块由操作系统缓存。 此外，Repository很有可能已根据段缓存到其主内存中。 因此，重新渲染的速度比您现在将其他页面逐出和从各种缓存中逐出时要快得多。

缓存很困难，对依赖于缓存的系统的测试也很困难。 那么，你能做什么来让现实生活更加准确？

我们认为您必须进行多个测试，并且您必须提供多个性能指标来衡量您的解决方案的质量。

如果您已有网站，请测量请求数以及请求的分发方式。 尝试为使用相似请求分布的测试建模。 添加一些随机性不会带来伤害。 您不必模拟可加载静态资源（如JS和CSS）的浏览器——那些并不重要。 它们最终会在浏览器中或调度程序中缓存，但不会显着增加负载。 但引用的图像确实很重要。 在旧日志文件中查找其分发，并建立类似的请求模式。

现在，使用Dispatcher进行测试，而根本不缓存。 那是你最坏的情况。 了解在最糟糕的情况下，您的系统会变得不稳定的峰值负载。 如果需要，还可以取出几个调度程序／发布腿，让情况变得更糟。

接下来，对所有所需的缓存设置执行相同的测试，将其设置为“开”。 慢慢提高并行请求的温度，查看在这些最佳情况下系统可以占用多少时间。

通常情况下，运行测试时启用调度程序，但也会发生一些失效。 通过使用cronjob触摸statfiles或以不定期的间隔向调度程序发送失效请求，可以模拟该情况。 不要忘记时不时清除一些非自动失效的资源。

您可以通过增加失效请求和增加负载来改变上一个方案。

这比线性负载测试要复杂得多，但对您的解决方案更有信心。

你可能会回避努力。 但是，在发布系统上至少进行一次最坏情况测试，测试页数较多（平均分发），以了解系统的限制。 请确保正确解释最佳案例的数量，并为系统配备足够的空间。