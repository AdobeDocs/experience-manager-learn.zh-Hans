---
title: “第3章 — 高级Dispatcher缓存主题”
description: 这是AEM中缓存的三部分系列中的第3部分。 前两个部分重点介绍Dispatcher中的普通http缓存以及存在哪些限制。 本部分讨论如何克服这些限制的一些想法。
feature: Dispatcher
topic: Architecture
role: Architect
level: Intermediate
exl-id: 7c7df08d-02a7-4548-96c0-98e27bcbc49b
source-git-commit: 4b47daf82e27f6bea4be30e3cdd132f497f4c609
workflow-type: tm+mt
source-wordcount: '6187'
ht-degree: 0%

---

# 第3章 — 高级缓存主题

*“计算机科学只有两个难题：缓存失效和命名问题。”*

 — 菲尔·卡尔顿

## 概述

这是AEM缓存系列三部分中的第3部分。 前两个部分重点介绍Dispatcher中的普通http缓存以及存在哪些限制。 本部分讨论如何克服这些限制的一些想法。

## 一般缓存

[第1章](chapter-1.md) 和 [第2章](chapter-2.md) 主要针对Dispatcher。 我们已经解释了基本知识、限制以及您需要进行某些权衡的位置。

缓存的复杂性和复杂性不是Dispatcher特有的问题。 一般而言，缓存比较困难。

实际上，将Dispatcher作为工具箱中的唯一工具是一个真正的限制。

在本章中，我们希望进一步拓宽有关缓存的观点，并提出一些有关如何克服Dispatcher的某些不足的想法。 没有灵丹妙药 — 您必须在项目中做出权衡。 请记住，在缓存和失效准确性中总是伴随着复杂性，而在复杂性中总是伴随着错误的可能性。

你必须在这些领域做出取舍，

* 性能和延迟
* 资源消耗/CPU负载/磁盘使用情况
* 准确性/货币/过时/安全性
* 简单/复杂性/成本/可维护性/错误倾向

这些维度在一个相当复杂的系统中相互关联。 没有简单的if-this-then-that。 使系统更简单可使其更快或更慢。 它可以降低您的开发成本，但会增加帮助台的成本，例如，如果客户看到过时内容或抱怨网站速度缓慢。 所有这些因素都需要相互考虑和平衡。 但现在你已经有一个好主意，即没有银弹或只有一个“最佳实践” — 只有大量不良实践和少数好的实践。

## 链接缓存

### 概述

#### 数据流

将页面从服务器传送到客户端的浏览器会跨越多个系统和子系统。 如果您仔细观察，需要从源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据跳转到源数据

![典型CMS应用程序的数据流](assets/chapter-3/data-flow-typical-cms-app.png)

*典型CMS应用程序的数据流*

<br> 

让我们从硬盘上需要显示在浏览器中的一段数据开始我们的历程。

#### 硬件和操作系统

首先，硬盘驱动器(HDD)本身在硬件中内置了一些缓存。 其次，装载硬盘的操作系统使用可用内存来缓存频繁访问的块，以加快访问速度。

#### 内容存储库

下一个级别是CRX或Oak - AEM使用的文档数据库。 CRX和Oak将数据划分为可以缓存在内存中的区段，以避免访问硬盘变慢。

#### 第三方数据

大多数较大的Web安装也具有第三方数据；数据来自产品信息系统、客户关系管理系统、旧版数据库或任何其他任意Web服务。 在需要时，无需从源中拉取此数据，尤其是当已知数据更改不太频繁时。 因此，如果它未在CRX数据库中同步，则可以缓存。

#### 业务层 — 应用程序/模型

通常，您的模板脚本不会通过JCR API渲染来自CRX的原始内容。 最有可能的情况是，您中间有一个业务层，该业务层合并、计算和/或转换业务域对象中的数据。 猜猜看，如果这些操作成本高昂，您应该考虑缓存它们。

#### 标记片段

现在，模型是呈现组件标记的基础。 为何不也缓存渲染的模型？

#### Dispatcher、CDN和其他代理

关闭会将渲染的HTML页转到Dispatcher。 我们已经讨论过，Dispatcher的主要用途是缓存HTML页面和其他Web资源（尽管其名称为）。 在资源到达浏览器之前，它可能会传递一个反向代理（可以缓存）和一个也用于缓存的CDN。 客户端可能位于办公室中，仅通过代理授予Web访问权限，该代理可能决定缓存以节省流量。

#### 浏览器缓存

最后但同样重要的是，浏览器也会缓存。 这是一项容易被忽视的资产。 但它是缓存链中距离最近且速度最快的缓存。 很遗憾，不会在用户之间共享，但仍在一个用户的不同请求之间共享。

### 缓存位置和原因

那是一长串潜在的缓存。 我们都面临着一些问题，我们看到了过时的内容。 但是考虑到这个过程有几个阶段，它大多数时候都有效，这真是个奇迹。

但是，在供应链中的哪个环节进行缓存才有意义？ 开始的时候？ 最后呢？ 到处都是？ 这取决于很多因素。 即使同一网站中的两个资源也可能希望获得该问题的不同答案。

为了让你大致了解你可能会考虑哪些因素，

**生存时间**  — 如果对象的固有生存时间较短（流量数据的生存时间可能比天气数据短），则可能并不值得缓存。

**生产成本 —** 重新生产和交付对象是多么昂贵（就CPU周期和I/O而言）。 如果它是廉价缓存，则可能没有必要。

**大小**  — 大型对象需要缓存更多资源。 这可能是一个限制因素，必须与收益相平衡。

**访问频率**  — 如果很少访问对象，则缓存可能无效。 在它们从缓存中第二次访问之前，它们只会失效或失效。 此类项目只会阻塞内存资源。

**共享访问**  — 应在链的上方进一步缓存多个实体使用的数据。 实际上，缓存链不是链，而是树。 存储库中的一段数据可能由多个模型使用。 这些模型进而可以由多个渲染脚本用于生成HTML片段。 这些片段包含在多个页面中，这些页面通过浏览器中的专用缓存分发给多个用户。 因此，“共享”并不意味着只在人与人之间共享，而不是在软件碎片之间共享。 如果要查找潜在的“共享”缓存，只需将树追溯到根并查找公共祖先 — 即应缓存的位置。

**地理空间分布**  — 如果您的用户分布在世界各地，使用分布式缓存网络可能有助于减少延迟。

**网络带宽和延迟**  — 说到延迟，您的客户是谁，他们使用哪种网络？ 或许您的客户是某个缺发达国家使用3G连接老一代智能手机的移动客户？ 请考虑创建较小的对象并将其缓存在浏览器缓存中。

这份清单目前还不够全面，但我们认为你现在已经明白了。

### 链式缓存的基本规则

同样 — 缓存很难。 让我们分享一些基本规则，这些规则是从以前的项目中提取的，可以帮助您避免项目中出现问题。

#### 避免双重缓存

最后一章介绍的每个层都为缓存链提供了一些价值。 要么通过节省计算周期，要么通过让数据更接近消费者。 在链中的多个阶段缓存一段数据并没有错，但您应该始终考虑下一阶段的好处和成本。 在Publish系统中缓存整个页面通常没有任何好处，因为在Dispatcher中已经这样做了。

#### 混合失效策略

有三种基本的失效策略：

* **TTL，生存时间：** 对象在固定时间（例如“从现在起2小时”）后过期
* **过期日期：** 对象将在定义的未来时间过期（例如“2019年6月10日下午5:00”）
* **基于事件：** 对象被平台中发生的事件（例如，当页面被更改和激活时）显式失效

现在，您可以在不同的缓存层上使用不同的策略，但有一些策略是“有毒”的。

#### 基于事件的失效

![纯基于事件的失效](assets/chapter-3/event-based-invalidation.png)

*纯基于事件的失效：从内部缓存到外层失效*

<br> 

纯事件失效是理解最简单、最容易在理论上正确和最准确的失效方法。

简而言之，当对象发生更改后，缓存将逐个失效。

您只需记住一条规则：

始终使从内部到外部缓存失效。 如果先使外部缓存失效，则可能会重新缓存内部缓存的过时内容。 不要在何时重新刷新缓存进行任何假设 — 请确保。 最好是通过触发外部缓存的失效 _之后_ 使内部节点失效。

这就是理论了。 但实际上，确实存在许多疑问。 事件必须分发 — 可能通过网络分发。 在实际应用中，这使其成为最难实现的失效方案。

#### 自动 — 修复

对于基于事件的失效，您应该有一个应急计划。 如果缺少失效事件，该怎么办？ 一个简单的策略就是在一段时间后使无效或清除。 因此 — 您可能错过了此次活动，现在提供了过时的内容。 但您的对象还具有仅数小时（天）的隐式TTL。 因此，这个体系最终会自我修复。

#### 纯基于TTL的失效

![基于未同步TTL的失效](assets/chapter-3/ttl-based-invalidation.png)

*基于未同步TTL的失效*

<br> 

这个计划也相当常见。 您可以栈叠多个缓存层，每个缓存层都有权在特定时间内为某个对象提供服务。

它易于实施。 不幸的是，很难预测数据的有效寿命。

![延长内部物体寿命盘的外壳](assets/chapter-3/outer-cache.png)

*延长内部对象寿命的外部高速缓存*

<br> 

请看上图。 每个缓存层都会引入2分钟的TTL。 现在 — 总体TTL也必须2分钟，对吗？ 不尽然。 如果外层在对象失效之前获取对象，则外层实际上会延长对象的有效生存时间。 在这种情况下，有效活动时间可以是2到4分钟。 假设您同意业务部门的意见，那么一天是可以容忍的，而且您有四个缓存层。 每个层上的实际TTL不得超过6小时……正在增加缓存失败率……

我们并不是说这是一个糟糕的计划。 你应该知道它的极限。 这是一个简单好用的策略。 仅当网站的流量增加时，您才可以考虑使用更准确的策略。

*通过设置特定日期同步失效时间*

#### 基于到期日期的失效

如果您在内部对象上设置特定日期并将其传播到外部缓存，则可获得更可预测的有效生命周期。

![同步到期日期](assets/chapter-3/synchronize-expiration-dates.png)

*同步到期日期*

<br> 

但是，并非所有缓存都能传播日期。 而且，当外部缓存聚合两个具有不同过期日期的内部对象时，它可能会变得非常糟糕。

#### 混合基于事件和基于TTL的失效

![混合基于事件和基于TTL的策略](assets/chapter-3/mixing-event-ttl-strategies.png)

*混合基于事件和基于TTL的策略*

<br> 

AEM世界中的另一个常见方案是在内部缓存（例如，内存中的缓存，事件可以近乎实时地处理）中使用基于事件的失效，而在外部使用基于TTL的缓存，您可能无权访问显式失效。

在AEM世界中，当基础资源发生更改，并且您将此更改事件传播到也可基于事件工作的Dispatcher时，发布系统中的业务对象和HTML片段的内存缓存将失效。 例如，您前面会有一个基于TTL的CDN。

在Dispatcher之前放置一层（短）基于TTL的缓存可以有效地缓和自动失效后通常会出现的峰值。

#### 混合TTL — 和基于事件的失效

![混合TTL — 和基于事件的失效](assets/chapter-3/toxic.png)

*毒性：混合TTL — 和基于事件的失效*

<br> 

这种组合是有毒的。 切勿在基于TTL或到期的缓存之后放置和基于事件的缓存。 还记得我们在“纯TTL”战略中所具有的溢出效应吗？ 同样的效应在这里可以观察到。 只有已发生的外部缓存失效事件才可能不会再次发生 — 将来，这可以将缓存对象的生命周期扩展到无限。

![基于TTL和基于事件的组合：溢出到无限](assets/chapter-3/infinity.png)

*基于TTL和基于事件的组合：溢出到无限*

<br> 

## 部分缓存和内存缓存

可以挂接到渲染过程的阶段以添加缓存层。 从获取远程数据传输对象或创建本地业务对象，到缓存单个组件的呈现标记。 我们将在以后的教程中介绍具体实施。 但是，您可能计划自己已经实施了其中一些缓存层。 因此，我们至少可以在这里引入基本原则 — 和格言。

### 警告词

#### 遵守访问控制

这里介绍的技术非常强大且 _必需_ 每个AEM开发人员工具箱中的。 但不要太激动，明智地使用它们。 通过将对象存储在缓存中并在后续请求中将其共享给其他用户，实际上意味着规避访问控制。 这通常不是面向公众的网站上的问题，但在用户需要登录才能访问网站时可能会出现此问题。

假设您将站点主菜单的HTML标记存储在内存缓存中，以便在不同的页面之间共享该标记。 实际上，这是一个存储部分渲染的HTML的完美示例，因为创建导航通常很昂贵，因为它需要遍历大量页面。

您并非在所有页面之间共享相同的菜单结构，而是与所有用户共享该菜单结构，这会使其效率更高。 但等待……但可能菜单中有一些项目仅保留给特定用户组。 在这种情况下，缓存可能会变得更复杂。

#### 仅缓存自定义业务对象

如果有的话（这是最重要的建议），我们可以为您提供：

>[!WARNING]
>
>仅缓存属于您的、不可变、您自己构建的、浅层且没有传出引用的对象。

这是什么意思？

1. 您不知道其他人的对象的预期活动周期。 假定您获得了对请求对象的引用，并决定对其进行缓存。 现在，请求已结束，并且servlet容器希望将该对象循环用于下一个传入请求。 在这种情况下，其他人正在更改您认为由您独占控制的内容。 不要忽视这一点 — 我们在一个项目中看到了类似的情况。 客户看到的是其他客户数据，而不是他们自己的数据。

2. 只要某个对象被其他引用链引用，就无法从栈中删除该对象。 如果您在缓存中保留了一个参考的所谓的小对象，假设4MB的图像表示形式，则您很有可能遇到内存泄漏问题。 缓存应基于弱引用。 但是 — 弱引用无法按预期工作。 这是产生内存泄漏并结束内存不足错误的最佳方法。 而且，您不知道外部对象的保留内存的大小是多少，对吗？

3. 特别是在Sling中，您可以使每个对象（几乎）彼此适应。 考虑将资源放入缓存。 下一个请求（具有不同的访问权限）将获取该资源并将其调整到resourceResolver或会话中以访问他无权访问的其他资源。

4. 即使您通过AEM在资源周围创建一个精简“包装器”，也不得缓存该内容，即使它是您自己的不可变内容。 包装的对象将是一个引用（我们之前禁止使用该引用），如果我们看起来很锐利，它基本上会产生与上一项中所述相同的问题。

5. 如果要缓存，请将原始数据复制到自己的缓存对象中，以创建自己的对象。 您可能希望通过引用链接您自己的对象之间 — 例如，您可能希望缓存对象树。 没关系 — 但只缓存您刚刚在同一请求中创建的对象 — 并且没有从其他位置请求的对象（即使是“您的”对象的名称空间）。 _复制对象_ 是关键。 并确保一次性清除链接对象的整个结构，并避免传入和传出对结构的引用。

6. 是 — 并且使对象不可变。 私有属性，仅限且无设置者。

这是很多规则，但值得遵循。 即使你经验丰富，非常聪明，一切都在掌控之中。 您项目中的年轻同事刚刚从大学毕业。 他不知道所有这些陷阱。 如果没有隐患，就没有可避免的。 简单明了，易于理解。

### 工具和库

本系列介绍如何理解相关概念，使您能够构建最适合用例的架构。

我们并没有特别推广任何工具。 但给你提示如何评估它们。 例如，从6.0版开始，AEM提供了一个具有固定TTL的简单内置缓存。你用得着吗？ 可能不在发布中，其中基于事件的缓存位于链中（提示：Dispatcher）。 但对于作者来说，这或许是一个不错的选择。 此外，AdobeACS Commons有一个HTTP缓存，可能值得考虑。

或者，您基于成熟的缓存框架(例如 [Ehcache](https://www.ehcache.org). 这可用于缓存Java对象和渲染的标记(`String` 对象)。

在一些简单情况下，您还可以与使用并发散列图相处得来 — 在这里，您很快会在工具或技能中看到限制。 并发与命名和缓存一样难以主控。

#### 引用

* [ACS Commons http缓存 ](https://adobe-consulting-services.github.io/acs-aem-commons/features/http-cache/index.html)
* [缓存框架](https://www.ehcache.org)

### 基本术语

我们不会在这里深入探讨缓存理论，但我们觉得有必要提供几个热词，以便您有一个良好的开端。

#### 缓存逐出

我们谈了很多无效和清除的事情。 _缓存逐出_ 与以下术语相关：条目被逐出后，将不再可用。 但是，逐出不会发生在条目过期时，而是发生在缓存已满时。 较新或“较重要”的项目会将较旧或较不重要的项目推出缓存。 你不得不牺牲哪些条目是一个个案决定。 您可能希望驱逐最早使用的或很少使用或最后访问时间很长的那些文件。

#### 抢占式缓存

抢占式缓存是指在条目失效或被视为过期时，使用新内容重新创建条目。 当然 — 您只需使用一些资源即可做到这一点，您确定可以频繁且立即访问。 否则，在创建可能永远不会被请求的缓存条目时将会浪费资源。 通过抢先创建缓存条目，您可以减少缓存失效后对资源的第一个请求的延迟。

#### 缓存预热

缓存预热与抢占式缓存密切相关。 虽然你不会用这个术语来形容实时系统。 与前者相比，其时间约束更少。 失效后不会立即重新缓存，而是在时间允许时逐渐填充缓存。

例如，您从负载平衡器中取出Publish / Dispatcher代码以对其进行更新。 在重新集成它之前，您将自动爬取最常访问的页面，以将其重新放入缓存。 当缓存“热” — 已充分填充时，您将腿重新集成到负载平衡器中。

或者你一次重新整合这条腿，但是你把流量调节到这条腿，这样它就有机会通过定期使用来暖和它的缓存。

或者，您可能还希望在系统空闲时缓存一些不太经常访问的页面，以便在实际请求访问这些页面时减少延迟。

#### 缓存对象标识、有效负载、失效依赖项和TTL

一般而言，缓存的对象或“条目”有五个主要属性，

#### 键

这是标识，即用于标识和对象的属性。 检索有效负载或从缓存中清除有效负载。 例如，Dispatcher使用页面的URL作为键。 请注意，Dispatcher不使用页面路径。 这不足以区分不同的渲染。 其他缓存可能使用不同的键。 我们稍后将看到一些示例。

#### 值/有效负载

这是对象的宝箱，您希望检索的数据。 对于Dispatcher，则为文件内容。 但它也可以是Java对象树。

#### TTL

我们已经覆盖了TTL。 在此时间后，条目将被视为过时，并且不应再发送。

#### 依赖关系

这与基于事件的失效相关。 该对象依赖哪些原始数据？ 我们已经说过，在第一部分中，真实而准确的依赖性跟踪过于复杂。 但根据我们对系统的了解，您可以使用更简单的模型来近似依赖关系。 我们使足够多的对象失效，以清除过时的内容……而且可能无意中超过了所需的内容。 然而，我们试图保持在“清除所有内容”的底线。

哪些对象取决于每个应用程序中的其他对象是真实的。 我们稍后将给出一些有关如何实施依赖关系策略的示例。

### HTML片段缓存

![在不同页面上重用渲染的片段](assets/chapter-3/re-using-rendered-fragment.png)

*在不同页面上重用渲染的片段*

<br> 

HTML片段缓存是一个强大的工具。 其思想是将组件生成的HTML标记缓存到内存缓存中。 你可能会问，我为什么要那么做？ 无论如何，我都会在Dispatcher中缓存整个页面的标记 — 包括该组件的标记。 我们同意。 可以，但每页一次。 您未在页面之间共享该标记。

想象一下，您正在每个页面顶部渲染导航。 每个页面上的标记看起来都一样。 但您正在对每个页面重复渲染它，这不在Dispatcher中。 并记住：自动失效后，所有页面都需要重新渲染。 基本上，您运行的是相同的代码，结果相同，执行了数百次。

根据我们的经验，渲染嵌套的顶部导航是一项非常昂贵的任务。 通常，要遍历文档树的大部分来生成导航项目。 即使您只需要导航标题和URL ，页面也必须加载到内存中。 而他们正阻塞着宝贵的资源。 一遍又一遍。

但组件会在多个页面之间共享。 共享某些内容即表示使用缓存。 因此 — 您要执行的操作是检查导航组件是否已渲染和缓存，并且不是重新渲染而是仅发出缓存值。

该计划有两个很好的细节，很容易被忽视：

1. 您正在缓存Java字符串。 String没有任何传出引用，并且不可更改。 因此，考虑到上述警告，这是超级安全的。

2. 失效也非常简单。 每当有任何内容更改您的网站时，您都希望使此缓存条目失效。 重建相对便宜，因为它只需要执行一次，然后被数百个页面重复使用。

这对您的发布服务器来说是一大安慰。

### 片段缓存的实施

#### 自定义标记

过去，将JSP用作模板引擎时，使用自定义JSP标记来封装组件渲染代码是非常常见的。

```
<!-- Pseudo Code -->

<myapp:cache
  key=' ${info.homePagePath} + ${component.path}'
  cache='main-navigation'
  dependency='${info.homePagePath}'>

… original components code ..

</myapp:cache>
```

的自定义标记，将捕获其主体并将其写入缓存或阻止执行其主体并输出缓存条目的有效负载。

“键”是它将在主页上拥有的组件路径。 我们不在当前页面上使用组件的路径，因为这将为每个页面创建一个缓存条目 — 这与我们共享该组件的意图相冲突。 我们也不只是使用组件相对路径(`jcr:conten/mainnavigation`)，因为这样会阻止我们在不同站点中使用不同的导航组件。

“缓存”是存储条目的位置。 您通常有多个将项目存储到的缓存。 其中每个选项的行为可能会稍有不同。 因此，区分存储的内容是件好事 — 即使最终只是字符串也是如此。

“依赖项”是缓存条目所依赖的对象。 “主导航”缓存可能有一个规则，如果节点“依赖项”下有任何更改，则必须清除相应的条目。 因此 — 您的缓存实施需要将其自身注册为存储库中的事件侦听器，以便了解更改，然后应用特定于缓存的规则来找出需要失效的内容。

以上只是一个例子。 您还可以选择拥有一棵缓存树。 其中，第一层用于分隔站点（或租户），第二层用于划分内容类型（例如“主导航”），这使您无需添加主页路径，如上面的示例所示。

顺便说一下，您也可以将此方法用于更现代的基于HTL的组件。 然后，您的HTL脚本周围会有一个JSP包装器。

#### 组件筛选器

但在纯HTL方法中，您宁可使用Sling组件过滤器构建片段缓存。 我们还没有看到这种情况，但我们将采取这种办法处理这个问题。

#### Sling Dynamic 包括

如果您在不断变化的环境（不同页面）的上下文中有一些常量（导航），则使用片段缓存。

但也可能相反，一个相对固定的上下文（一个很少更改的页面）以及该页面上一些不断变化的片段（例如，实时滚动条）。

在这种情况下，您可以 [Sling Dynamic Include](https://sling.apache.org/documentation/bundles/dynamic-includes.html) 一个机会。 本质上，这是一个组件过滤器，它会包装动态组件，并且不会将组件渲染到页面中，而是会创建一个引用。 此引用可以是Ajax调用 — 以便浏览器包含该组件，因此可以静态缓存周围的页面。 或者，Sling Dynamic Include可以生成SSI指令（服务器端包含）。 此指令将在Apache Server中执行。 如果您利用Varnish或支持ESI脚本的CDN，您甚至可以使用ESI - Edge Side Include指令。

![使用Sling Dynamic Include的请求的序列图](assets/chapter-3/sequence-diagram-sling-dynamic-include.png)

*使用Sling Dynamic Include的请求的序列图*

<br> 

SDI文档规定，在处理动态组件时，应禁用以“*.nocache.html”结尾的URL的缓存，这是合理的。

您可能会看到另一个如何使用SDI的选项：如果您 _不要_ 为包含禁用Dispatcher缓存，Dispatcher的行为类似于片段缓存，类似于我们在上一章中所述：页面和组件片段均等地独立缓存到Dispatcher中，并在请求页面时由Apache服务器中的SSI脚本拼合在一起。 这样，您就可以实施共享组件，例如主导航（假定您始终使用相同的组件URL）。

理论上，这应该有效。 但是……

我们建议您不要这样做：您将失去为真正的动态组件绕过缓存的功能。 SDI是在全局范围内配置的，您对“post-mans-fragment-cache”所做的更改也将应用于动态组件。

我们建议您仔细研究SDI文档。 还有其他一些限制，但在某些情况下SDI是一个有价值的工具。

#### 引用

* [docs.oracle.com — 如何编写自定义JSP标记](https://docs.oracle.com/cd/E11035_01/wls100/taglib/quickstart.html)
* [Dominik Suß — 创建和使用组件过滤器](https://www.slideshare.net/connectwebex/prsentation-dominik-suess)
* [sling.apache.org - Sling Dynamic Include](https://sling.apache.org/documentation/bundles/dynamic-includes.html)
* [helpx.adobe.com — 在AEM中设置Sling Dynamic Include](https://helpx.adobe.com/experience-manager/kt/platform-repository/using/sling-dynamic-include-technical-video-setup.html)


#### 模型缓存

![基于模型的缓存：一个业务对象具有两个不同的渲染](assets/chapter-3/model-based-caching.png)

*基于模型的缓存：一个业务对象具有两个不同的渲染*

<br> 

让我们再次通过导航重新审视此案例。 我们假设每个页面都需要相同的导航标记。

但也许事实并非如此。 您可能希望在表示 _当前页面_.

```
Travel Destinations

<ul class="maninnav">
  <li class="currentPage">Travel Destinations
    <ul>
      <li>Finland
      <li>Canada
      <li>Norway
    </ul>
  <li>News
  <li>About us
<ul>
```

```
News

<ul class="maninnav">
  <li>Travel Destinations
  <li class="currentPage">News
    <ul>
      <li>Winter is coming>
      <li>Calm down in the wild
    </ul>
  <li>About us
<is
```

这是两种完全不同的渲染。 尽管如此， _业务对象_  — 完整的导航树 — 是相同的。  此 _业务对象_  下面是一个对象图，表示树中的节点。 此图形可以轻松存储在内存缓存中。 但请记住，此图形不得包含任何对象或引用您未自行创建的任何对象，尤其是当前的JCR节点。

#### 浏览器中的缓存

我们已经提到了浏览器中缓存的重要性，并且提供了许多很好的教程。 最后，对于浏览器，Dispatcher只是一个遵循HTTP协议的Web服务器。

然而，尽管存在这种理论，我们还是收集了一些知识，这些知识是我们独一无二的，而且我们想要分享。

从本质上讲，可以通过两种不同的方式利用浏览器缓存，

1. 浏览器缓存了资源，知道该资源的确切到期日期。 在这种情况下，它不会再次请求资源。

2. 浏览器具有资源，但不确定它是否仍然有效。 在这种情况下，它会询问Web服务器（在本例中为Dispatcher）。 如果资源自您上次交付以来已修改，请给我该资源。 如果未更改，服务器将通过“304 — 未更改”进行响应，并且只传输元数据。

#### 调试

如果您正在优化用于浏览器缓存的Dispatcher设置，则在浏览器和Web服务器之间使用桌面代理服务器将非常有用。 我们更喜欢Karl von Randow的“Charles Web Debugging Proxy”。

使用Charles ，您可以读取传输到服务器或从服务器传输的请求和响应。 并且，您可以了解有关HTTP协议的更多信息。 现代浏览器也提供了一些调试功能，但桌面代理的功能是前所未有的。 您可以处理传输的数据、限制传输、重放单个请求等等。 用户界面布局清晰，功能比较全面。

最基本的测试是将网站作为普通用户使用（代理介于两者之间），如果静态请求（对/etc/...）的数量随着时间的推移而逐渐减少，则签入代理 — 因为这些请求应位于缓存中，不再被请求。

我们发现，代理可以提供更清晰的概述，因为缓存的请求不会显示在日志中，而某些浏览器内置调试器仍会将这些请求显示为“0毫秒”或“从磁盘”。 这很正常，也很准确，但可能会使您的视图蒙上阴影。

然后，您可以深入查看并检查已传输文件的标头，以查看“Expires”http标头是否正确。 您可以通过if-modified-since标头设置来重播请求，以查看服务器是否正确响应了304或200响应代码。 您可以观察异步调用的时间，还可以在一定程度上测试您的安全假设。 请记住，我们告诉过您不要接受所有不是明确期望的选择器？ 在这里，您可以播放URL和参数，看看您的应用程序是否运行良好。

在调试缓存时，我们只要求您不要做一件事：

不要在浏览器中重新加载页面！

“浏览器重新加载”， _简单重新加载_ 以及 _强制重装_ (&quot;_shift-reload_“)与普通页面请求不同。 简单的重新加载请求会设置标头

```
Cache-Control: max-age=0
```

而Shift — 重新加载（按住Shift键的同时单击重新加载按钮）通常会设置请求标头

```
Cache-Control: no-cache
```

这两个标头具有相似但略有不同的效果，但最重要的是，当您从URL插槽中打开URL时，或者在网站上使用链接时，它们与普通请求完全不同。 正常浏览不会设置Cache-Control标头，但可能会设置if-modified-since标头。

因此，如果要调试正常的浏览行为，您应该完全按照以下步骤操作： _正常浏览_. 使用浏览器的重新加载按钮是看不到配置中缓存配置错误的最佳方法。

使用您的查尔斯代理来查看我们正在讨论的内容。 可以 — 在打开它时，您可以在此重新显示请求。 无需从浏览器重新加载。

## 性能测试

通过使用代理，您可以了解页面的计时行为。 当然，这远不是一项性能测试。  性能测试需要多个客户端并行请求您的页面。

一个常见的错误（我们经常看到）是，性能测试仅包括超少数量的页面，并且这些页面仅从Dispatcher缓存中交付。

如果将应用程序提升到实时系统，则负载与测试负载完全不同。

在实时系统上，访问模式并不是您在测试中（主页和少数内容页面）具有的均匀分布的页面数量较少。 页数更大，请求分布非常不均匀。 并且 — 当然 — 无法从缓存中完全为实时页面提供服务：来自发布系统的失效请求使您的绝大部分宝贵资源自动失效。

啊，是的 — 而且在重建Dispatcher缓存时，您会发现Publish系统的行为也完全不同，具体取决于您请求的是少量的页面，还是更大的页面。 即使所有页面都同样复杂，它们的数量也会起到一定作用。 还记得我们怎么说链式缓存吗？ 如果您总是请求同样数量的页面，则可能情况良好，即包含原始数据的相应块位于硬盘缓存中，或者这些块由操作系统缓存。 此外，存储库很有可能已在主内存中缓存了相应的区段。 因此，重新渲染的速度明显快于其他页面从各种缓存中逐出时的速度。

缓存和测试依赖于缓存的系统都很困难。 那么，怎样才能获得更准确的现实生活场景呢？

我们认为您必须执行多项测试，并且必须提供多个绩效指标作为解决方案质量的衡量标准。

如果您已经有一个网站，请测量请求的数量及其分发方式。 尝试为使用相似请求分布的测试建模。 添加随机性没什么坏处。 您不必模拟会加载JS和CSS等静态资源的浏览器 — 这些其实并不重要。 最终，它们会缓存在浏览器或Dispatcher中，并且它们相加不会显着增加负载。 但参考的图像确实重要。 找出它们在旧日志文件中的分布情况，并对类似的请求模式进行建模。

现在，在Dispatcher完全不缓存的情况下进行测试。 这是你最坏的情况。 了解在这种最恶劣的情况下，您的系统在哪个峰值负载变得不稳定。 如果您愿意，也可以删除一些Dispatcher/Publish分支，这会使问题变得更糟。

接下来，执行相同的测试，将所有必需的缓存设置设为“开”。 慢慢增加并行请求以预热缓存，并了解在这些最佳情况下，您的系统可容纳的容量。

一般情况下，运行测试时会启用Dispatcher，但也会发生一些无效情况。 您可以通过cronjob接触statfiles或不定时地向Dispatcher发送失效请求来模拟这种情况。 别忘了偶尔清除一些非自动失效的资源。

您可以通过增加失效请求和增加负载来更改最后一个方案。

这比线性负载测试要复杂一些，但给您的解决方案带来了更多信心。

你可能会回避这种努力。 但是，请至少对Publish系统进行最坏情况的测试，使其具有更多页面（均匀分布），以查看系统的限制。 确保，您能够正确解释最佳案例的数量，并为系统配置足够的余量。
