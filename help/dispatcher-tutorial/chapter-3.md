---
title: '"第3章 — 高级调度程序缓存主题"'
description: 这是要在AEM中缓存的三部分系列的第3部分。 前两个部分侧重于调度程序中的纯http缓存以及存在哪些限制。 本部分讨论了如何克服这些限制的一些想法。
feature: Dispatcher
topic: Architecture
role: Architect
level: Intermediate
translation-type: tm+mt
source-git-commit: d9714b9a291ec3ee5f3dba9723de72bb120d2149
workflow-type: tm+mt
source-wordcount: '6191'
ht-degree: 0%

---


# 第3章 — 高级缓存主题

*“在计算机科学中，只有两件很难的事：缓存失效和命名事项。”*

 — 菲尔·卡尔顿

## 概述

这是三部分的第3部分 — 要在AEM中缓存的系列。 前两个部分侧重于调度程序中的纯http缓存以及存在哪些限制。 本部分讨论了如何克服这些限制的一些想法。

## 一般缓存

[本系](chapter-1.md) 列第 [1](chapter-2.md) 章和第2章主要针对调度程序。我们已解释了基本因素、局限性以及您需要在何处做出某些取舍。

缓存复杂性和复杂性并非调度程序特有的问题。 通常，缓存很难。

将Dispatcher作为工具箱中唯一的工具实际上是一个真正的限制。

在本章中，我们希望进一步扩展缓存视图，并开发一些思路，帮助您克服Dispatcher的一些缺点。 没有万灵丹 — 在您的项目中，您必须做出权衡。 请记住，缓存和失效准确性总是会带来复杂性，而复杂性会带来错误。

你需要在这些领域进行权衡，

* 性能和延迟
* 资源消耗/CPU负载/磁盘使用
* 准确性/货币/稳定性/安全性
* 简单性/复杂性/成本/可维护性/容易出错

这些维度在一个相当复杂的系统中相互关联。 没有简单的，如果，那么。 使系统更简单可以使系统更快或更慢。 它可以降低您的开发成本，但会增加服务台的成本，例如，如果客户看到陈旧的内容或抱怨网站运行缓慢。 所有这些因素都需要相互考虑和平衡。 但到现在，你应该已经有了一个好主意，那就是没有万灵丹，也没有一个“最佳实践” — 只有很多坏做法和一些好做法。

## 链式缓存

### 概述

#### 数据流

将页面从服务器传送到客户端的浏览器跨越多个系统和子系统。 如果仔细查看，需要从源数据到流数据的跳数很多，每个跳数都是缓存的潜在候选。

![典型CMS应用程序的数据流](assets/chapter-3/data-flow-typical-cms-app.png)

*典型CMS应用程序的数据流*

<br> 

让我们用一块位于硬盘上、需要在浏览器中显示的数据来开始我们的旅程。

#### 硬件和操作系统

首先，硬盘驱动器(HDD)本身在硬件中具有一些内置的缓存。 其次，装载硬盘的操作系统使用空闲内存缓存频繁访问的块以加速访问。

#### 内容存储库

下一级是CRX或Oak —AEM使用的文档数据库。 CRX和Oak将数据分为若干段，这些段可以缓存在内存中，以避免对硬盘的访问变慢。

#### 第三方数据

大多数较大的Web安装也包含第三方数据；来自产品信息系统、客户关系管理系统、传统数据库或任何其他任意web服务的数据。 无需在任何需要时从源中提取此数据，尤其是在已知更改不太频繁时。 因此，如果未在CRX数据库中同步，则可以缓存它。

#### 业务层 — 应用程序/模型

通常，模板脚本不会通过JCR API呈现来自CRX的原始内容。 您很可能在业务层之间有一个合并、计算和/或转换业务域对象中的数据。 猜猜怎么着 — 如果这些操作成本很高，您应该考虑缓存它们。

#### 标记片段

模型现在是组件标记渲染的基础。 为什么不也缓存渲染的模型？

#### 调度程序、CDN和其他代理

关闭会将呈现的HTML页转到调度程序。 我们已经讨论过，调度程序的主要用途是缓存HTML页面和其他Web资源（尽管有其名称）。 在资源到达浏览器之前，它可能会传递反向代理（可缓存）和CDN（也用于缓存）。 客户端可能位于办公室，仅通过代理授予Web访问权限，而代理可能决定缓存并保存流量。

#### 浏览器缓存

最后，但不是最不重要的是，浏览器也缓存了。 这是一项容易被忽视的资产。 但它是缓存链中最接近、最快的缓存。 很遗憾，它不是在用户之间共享的，而是仍在一个用户的不同请求之间共享。

### 缓存位置及原因

这是一长串潜在的缓存。 我们都面临着内容过时的问题。 但考虑到它有多少个阶段，它大部分时间都在运转，这是个奇迹。

但在这条链中，什么地方有什么意义呢？ 一开始？ 最后？ 到处？ 这取决于……它取决于很多因素。 即使同一网站中有两个资源也可能希望对该问题给出不同的答案。

大致了解您可能考虑哪些因素，

**生存时间**  — 如果对象具有较短的固有生存时间（流量数据的生存时间可能比天气数据短），则可能不值得缓存。

**生产成** 本 — 对象的再生产和投放（按CPU周期和I/O）是多贵。如果它便宜的缓存，可能就没有必要了。

**大小**  — 大型对象需要更多资源才能缓存。这可能是一个限制因素，必须与收益平衡。

**访问频率**  — 如果对象访问很少，缓存可能无效。它们只会过时或失效，然后才能从缓存中再次访问。 这些项目只会阻止内存资源。

**共享访问**  — 应在链的更上方对多个实体使用的数据进行缓存。事实上，缓存链不是链，而是树。 存储库中的一段数据可能由多个模型使用。 这些模型又可以由多个渲染脚本使用来生成HTML片段。 这些片段包括在多个页面中，这些页面在浏览器中使用其专用缓存分发给多个用户。 因此，“共享”并不意味着只在人与人之间共享，而是在软件之间共享。 如果要查找潜在的“共享”缓存，只需将树跟踪回根并查找共同的祖代，即可缓存。

**地理空间分** 布 — 如果您的用户分布于全球，使用缓存的分布式网络可能有助于减少延迟。

**网络带宽和延迟**  — 说到延迟，您的客户是谁，他们使用的是哪种网络？也许您的客户是使用旧一代智能手机3G连接的欠发达国家的移动客户？ 请考虑创建较小的对象并将其缓存到浏览器缓存中。

这个列表目前还不全面，但我们认为你们现在已经明白了。

### 链式缓存的基本规则

同样，缓存很困难。 让我们分享一些基本规则，这些基本规则是我们从以前的项目中提取的，它们可以帮助您避免项目中出现问题。

#### 避免多次缓存

在最后一章中介绍的每个图层都在缓存链中提供了一些值。 或者通过节省计算周期，或者通过让数据更贴近消费者。 将数据缓存到链的多个阶段并不错 — 但您应该始终考虑下一阶段的好处和成本。 在发布系统中缓存完整页面通常不提供任何好处 — 这在调度程序中已经完成。

#### 混合失效策略

有三种基本的失效策略：

* **TTL、生存时间：** 对象在固定时间后过期（例如，“2小时后”）
* **过期日** 期：对象在将来的定义时间过期（例如，“2019年6月10日下午5:00”）
* **基于事件** ：对象由平台中发生的事件（例如，当页面被更改和激活时）显式失效

现在，您可以在不同的缓存层上使用不同的策略，但有一些“有毒”策略。

#### 事件失效

![纯事件失效](assets/chapter-3/event-based-invalidation.png)

*纯事件失效：从内部缓存到外部图层无效*

<br> 

纯事件失效是最容易理解的失效，最容易理论上正确的失效，也是最准确的失效。

简单地说，在对象发生变化后，缓存逐个失效。

你只需要记住一个规则：

始终从内部到外部缓存无效。 如果首先使外部缓存失效，它可能会从内部缓存中重新缓存过时的内容。 不要在缓存何时重新更新时做出任何假设 — 请确保这一点。 最好，在&#x200B;_使内部缓存失效后触发外部缓存_&#x200B;的失效。

这就是理论。 但实际上，还有很多错误。 事件必须通过网络进行分发。 在实际中，这使其成为最难实施的失效方案。

#### 自动 — 修复

在基于事件的无效情况下，您应该有应急计划。 如果错过了失效事件怎么办？ 一个简单的策略是在一定时间后失效或清除。 因此 — 您可能错过了事件，现在提供陈旧的内容。 但是，您的对象的隐式TTL仅为几小时（天）。 最终，系统自动自我修复。

#### 纯TTL失效

![基于未同步TTL的失效](assets/chapter-3/ttl-based-invalidation.png)

*基于未同步TTL的失效*

<br> 

这个计划也是相当普遍的。 您堆叠多层缓存，每个缓存都有权在一定时间内服务对象。

易于实施。 不幸的是，很难预测某一数据的有效寿命。

![延长内物体寿命的外壳](assets/chapter-3/outer-cache.png)

*延长内部对象寿命的外部缓存*

<br> 

请考虑上面的插图。 每个缓存层引入2分钟的TTL。 现在 — 总TTL也必须2分钟，对吧？ 不是。 如果外层在对象失效之前读取该对象，则外层实际延长了对象的有效生存时间。 在这种情况下，有效的实时时间可以在2到4分钟之间。 考虑到你与业务部达成了一致，有一天是可以容忍的 — 而你有四层缓存。 每个图层上的实际TTL不得长于6小时……增加缓存丢失率……

我们并不是说这是一个坏计划。 你应该知道它的局限性。 这是一个好且容易的开始策略。 只有在网站流量增加时，您才能考虑更准确的策略。

*通过设置特定日期来同步失效时间*

#### 基于过期日期的失效

如果要在内部对象上设置特定日期并将其传播到外部缓存，则可获得更可预测的有效生命时间。

![同步过期日期](assets/chapter-3/synchronize-expiration-dates.png)

*同步过期日期*

<br> 

但是，并非所有缓存都能传播日期。 当外部缓存聚合两个具有不同过期日期的内部对象时，它会变得很讨厌。

#### 基于混合事件和基于TTL的失效

![混合基于事件和基于TTL的策略](assets/chapter-3/mixing-event-ttl-strategies.png)

*混合基于事件和基于TTL的策略*

<br> 

AEM世界中的一个常见方案是在内部缓存(例如，内存中缓存可以近乎实时地处理事件)和外部基于TTL的缓存中使用基于事件的失效，在内存中缓存中，您可能无法访问显式失效。

在AEM环境中，当基础资源发生更改并将此更改事件传播到调度程序时，发布系统中的业务对象和HTML片段将具有内存内存缓存，该缓存将失效。调度程序也基于事件工作。 前面是一个基于TTL的CDN。

在Dispatcher前面拥有一个基于（短）TTL的缓存层可以有效地柔化通常在自动失效后会发生的尖峰。

#### 基于混合TTL和事件的失效

![混合基于TTL和事件的失效](assets/chapter-3/toxic.png)

*有毒：混合基于TTL和事件的失效*

<br> 

这种组合是有毒的。 在基于TTL或Expiry的缓存后，切勿放置基于事件的缓存。 还记得“纯TTL”策略中的溢流效应吗？ 这里可以观察到同样的效果。 只有外部缓存的失效事件已发生，才可能不再发生 — 从未发生。这会将缓存对象的寿命扩展到无限。

![基于TTL和基于事件的组合：溢出到无限](assets/chapter-3/infinity.png)

*基于TTL和基于事件的组合：溢出到无限*

<br> 

## 部分缓存和内存中缓存

您可以挂接到渲染过程的舞台，以添加缓存图层。 从获取远程数据传输对象或创建本地业务对象到缓存单个组件的已渲染标记。 我们将在稍后的教程中介绍具体的实施。 但是，您可能计划已经自己实施了其中的一些缓存层。 因此，我们至少可以在此介绍基本原则 — 以及常识。

### 警告词

#### 尊重访问控制

此处介绍的技术相当强大，每个AEM开发人员的工具箱中都有&#x200B;_必备_。 但别太激动，明智地使用。 通过将对象存储在缓存中，并在后续请求中将其共享给其他用户，实际上意味着规避访问控制。 在面向公众的网站上，这通常不是问题所在，但在用户需要登录才能访问时可能会出现。

请考虑将站点主菜单的HTML标记存储在内存中缓存中，以便在不同页面之间共享。 实际上，对于将部分呈现的HTML存储为创建导航而言，这是一个绝佳的示例，通常成本很高，因为它需要遍历大量页面。

您不是在所有页面之间共享相同的菜单结构，而是与所有用户共享，这样更有效。 但是，等等……但是菜单中可能有些项目是仅为特定用户组保留的。 在这种情况下，缓存可能会变得更加复杂。

#### 仅缓存自定义业务对象

如果有的话 — 这是最重要的建议，我们可以给您：

>[!WARNING]
>
>仅缓存您自己构建的、浅的、没有传出引用的不可改变的对象。

这是什么意思？

1. 你不知道别人物品的预定生命周期。 请考虑您看到对请求对象的引用并决定缓存它。 现在，请求已结束，Servlet容器希望为下一个传入请求循环使用该对象。 在这种情况下，其他人正在更改您认为您拥有专属控制权的内容。 不要对此置之不理 — 我们在一个项目中看到了类似的情况。 客户看到的是其他客户数据，而不是他们自己的数据。

2. 只要对象被其他引用的链引用，就不能从堆中删除它。 如果您在缓存中保留引用的据信较小的对象，假设图像的4MB表示形式很有可能导致内存泄漏。 缓存应基于弱引用。 但是 — 弱引用并不像你预期的那样有效。 这是产生内存泄漏并导致内存不足错误的绝对最佳方法。 而且 — 你不知道这些外来物体保留的内存大小，对吧？

3. 尤其是在Sling中，您可以（几乎）将每个对象相互调整。 考虑将资源放入缓存。 下一个请求（具有不同的访问权限）将获取该资源并将其调整为resourceResolver或会话以访问他无法访问的其他资源。

4. 即使您在AEM中的资源周围创建了一个精简的“包装器”，您也不能缓存它 — 即使它是您自己的、不可变的。 包装的对象将是引用（我们以前禁止），如果我们看起来很清晰，这基本上会产生与上个项目中描述的相同的问题。

5. 如果要缓存，请通过将基元数据复制到自己的共享对象中来创建您自己的对象。 您可能希望通过引用在您自己的对象之间链接 — 例如，您可能希望缓存对象树。 没关系，但只缓存您刚刚在同一请求中创建的对象，而且没有从其他位置请求的对象（即使它是“您的”对象的名称空间）。 _复制_ 对象是关键。同时确保清除链接对象的整个结构，并避免对结构的传入和传出引用。

6. 是 — 并保持对象不变。 私有属性，仅限，无设置者。

这是很多规则，但值得遵循。 即使你经验丰富，非常聪明，一切尽在掌握。 你项目中的那个年轻同事刚大学毕业。 他不知道这些陷阱。 如果没有陷阱，就没什么可避免的。 使其简单易懂。

### 工具和库

该系列旨在了解概念并使您能够构建最适合您的使用案例的架构。

我们并不特别推广任何工具。 但是，请给您一些如何评估它们的提示。 例如，AEM具有简单的内置缓存，自6.0版以来具有固定TTL。是否使用它？ 在发布时，基于事件的缓存会在链中跟随(提示：调度程序)。 但对作者来说，这可能是一个不错的选择。 还有一个由Adobe ACS共享的HTTP缓存，值得考虑。

或者，您也可以根据[Ehcache](https://www.ehcache.org)等成熟的缓存框架构建自己的缓存。 这可用于缓存Java对象和呈现的标记（`String`对象）。

在某些简单的情况下，您还可以使用并发哈希映射来解决问题 — 无论在工具中还是技能中，您都会在此处快速看到限制。 并发与命名和缓存一样难以主控。

#### 引用

* [ACS Commons http缓存  ](https://adobe-consulting-services.github.io/acs-aem-commons/features/http-cache/index.html)
* [高速缓存框架](https://www.ehcache.org)

### 基本术语

我们不会在这里深入讨论缓存理论，但我们觉得必须提供一些热门词语，这样您就能获得一个很好的跳跃开始。

#### 缓存驱逐

我们谈论过很多关于失效和清除的问题。 _缓_ 存驱逐与以下术语相关：进入后，它被逐出，现在不再可用。但是，当条目过期时，逐出不会发生，而是当缓存已满时。 较新或“较重要”的项目将较旧或不太重要的项目从缓存中推出。 你必须牺牲哪些条目是个个案决定。 你可能想驱逐那些最老的，或者那些很少使用或最后被访问很久的。

#### 抢先缓存

抢先缓存是指在条目失效或被认为过时时，使用新内容重新创建条目。 当然，您只需使用一些资源即可完成此操作，您确实可以经常和立即访问这些资源。 否则，您将浪费资源创建可能从未请求的缓存条目。 通过抢先创建缓存条目，可以减少缓存失效后对资源的第一个请求的延迟。

#### 缓存预热

缓存预热与抢先缓存密切相关。 虽然你不会用这个术语来建立实时系统。 而且，与前者相比，它所受的时间约束也更少。 失效后不立即重新缓存，但在时间允许时逐步填充缓存。

例如，从负载平衡器中取出Publish / Dispatcher腿进行更新。 在重新集成之前，您会自动爬网访问频率最高的页面，以再次将它们放入缓存中。 当缓存“温暖”时 — 已充足填充，您将腿重新集成到负载平衡器中。

或者你可以立即重新整合这条腿，但是你把流量限制到那条腿，这样它就有机会通过常规使用来温暖它的缓存。

或者，您也希望在系统空闲时缓存一些访问频率较低的页面，以减少实际请求访问这些页面时的延迟。

#### 缓存对象标识、有效负荷、失效依赖项和TTL

通常，缓存对象或“条目”有五个主要属性，

#### 键

这是标识，您通过它来标识和对象。 要检索其有效负荷，或从缓存中清除它。 例如，调度程序使用页面的URL作为键。 请注意，调度程序不使用页面路径。 这并不足以区分不同的呈现方式。 其他缓存可能使用不同的键。 稍后我们将看到一些例子。

#### 值/有效负荷

这是物体的宝库，你想要检索的数据。 如果是调度程序，则它是文件内容。 但它也可以是Java对象树。

#### TTL

我们已经覆盖了TTL。 在此时间之后，某条目被视为过时且不应再传递。

#### 依赖关系

这涉及基于事件的失效。 该对象依赖哪些原始数据？ 在第一部分中，我们已经说过，真实而准确的依赖跟踪过于复杂。 但是，根据我们对系统的了解，您可以用一个更简单的模型来近似依赖关系。 我们使足够多的对象失效，以清除过时的内容……并且可能无意中清除了超出要求的内容。 但是，我们仍试图低于“清除一切”。

每个应用程序中哪些对象取决于其他对象是正版。 稍后，我们将给您一些如何实施依赖策略的示例。

### HTML片段缓存

![在不同页面上重新使用呈现的片段](assets/chapter-3/re-using-rendered-fragment.png)

*在不同页面上重新使用呈现的片段*

<br> 

HTML片段缓存是一个强大的工具。 其想法是缓存内存中缓存组件生成的HTML标记。 你可能会问，我为什么要这么做？ 我仍将整个页面的标记缓存在调度程序中 — 包括该组件的标记。 我们同意。 确实如此，但每页只需一次。 您不会在页面之间共享该标记。

想象一下，您正在每个页面的顶部渲染导航。 每个页面上的标记外观相同。 但是，您会对每个页面（不在Dispatcher中）一遍又一遍地渲染它。 记住：自动失效后，所有页面都需要重新渲染。 因此，基本上，您运行相同的代码并且结果也相同数百次。

从我们的经验来看，渲染嵌套的顶部导航是一个非常昂贵的任务。 通常，您遍历文档树的一大部分以生成导航项。 即使您只需要导航标题和URL，页面也必须加载到内存中。 在这里，他们正在塞满宝贵的资源。 一次又一次。

但组件是在多个页面之间共享的。 而共享是指使用缓存。 因此，您希望执行的操作是检查导航组件是否已经渲染和缓存，而不是重新渲染只发出缓存值。

这个计划有两个美妙的细节很容易错过：

1. 您正在缓存Java字符串。 字符串没有任何传出引用，并且是不可变的。 因此，考虑到上述警告，这是超级安全的。

2. 失效也非常容易。 只要任何内容更改您的网站，您就希望使此缓存条目失效。 重建相对便宜，因为它只需执行一次，然后被所有数百页重用。

这对您的发布服务器大有裨益。

### 片段缓存的实现

#### 自定义标记

在过去，您使用JSP作为模板引擎时，使用自定义JSP标签环绕组件呈现代码是很常见的。

```
<!-- Pseudo Code -->

<myapp:cache
  key=' ${info.homePagePath} + ${component.path}'
  cache='main-navigation'
  dependency='${info.homePagePath}'>

… original components code ..

</myapp:cache>
```

与捕获其正文并将其写入缓存或阻止执行其正文并输出缓存条目的有效负荷相比，自定义标记。

“关键”是它在主页上的组件路径。 我们不会在当前页面上使用组件的路径，因为这样会为每页创建一个缓存条目 — 这与我们共享该组件的意图相矛盾。 我们也不仅使用组件相对路径(`jcr:conten/mainnavigation`)，因为这样会阻止我们在不同站点中使用不同的导航组件。

“缓存”是存储条目的指示器。 通常，在将项目存储到的位置有多个缓存。 每一个可能都有点不同。 因此，区分存储内容是件好事，即使最终只是字符串。

“依赖关系”是缓存条目所依赖的。 “主导航”缓存可能有一条规则，即如果节点“依赖关系”下有任何更改，则必须清除相应条目。 因此，您的缓存实现需要将自身注册为存储库中的事件侦听器，以了解更改，然后应用特定于缓存的规则来找出需要失效的内容。

以上只是一个例子。 您还可以选择具有缓存树。 当第一层用于分离站点（或租户），而第二层用于分离内容，然后分支到内容类型（例如“主导航”）中时，这样，您就无需添加主页路径，如上例中所示。

顺便说一下，您还可以将此方法与更现代的基于HTL的组件一起使用。 然后，您的HTL脚本周围会有一个JSP包装器。

#### 组件过滤器

但是，在纯HTL方法中，您宁可使用Sling组件过滤器构建片段缓存。 我们还没有看到这个，但我们将采取这种方法来处理这个问题。

#### Sling Dynamic Include

如果您在更改环境（不同页面）的上下文中具有常量（导航），则使用片段缓存。

但您可能也有相反的内容，一个相对恒定的上下文（一个很少更改的页面）和该页面上一些不断更改的片段（例如，实时滚动条）。

在这种情况下，您可能会给[Sling Dynamic Includes](https://sling.apache.org/documentation/bundles/dynamic-includes.html)一个机会。 本质上，这是一个组件过滤器，它绕排动态组件，而不是将组件渲染到它创建引用的页面中。 此引用可以是Ajax调用，因此浏览器将包含该组件，因此可以静态缓存周围的页面。 或者，Sling Dynamic Include可以生成SSI指令（服务器端包括）。 此指令将在Apache服务器中执行。 如果您利用Hiset或支持ESI脚本的CDN，您甚至可以使用ESI - Edge Side Include指令。

![使用Sling Dynamic Include的请求序列图](assets/chapter-3/sequence-diagram-sling-dynamic-include.png)

*使用Sling Dynamic Include的请求序列图*

<br> 

SDI文档说，您应当禁用以“*.nocache.html”结尾的URL的缓存，这很有意义 — 因为您处理的是动态组件。

您可能会看到另一个如何使用SDI的选项：如果&#x200B;_未_&#x200B;禁用包含的调度程序缓存，则调度程序的操作类似于我们在上一章中描述的片段缓存：页面和组件片段在调度程序中平等、独立地缓存，并在请求页面时由Apache服务器中的SSI脚本拼接在一起。 这样，您可以实现共享组件（如主导航）（假定您始终使用相同的组件URL）。

理论上，这应该会奏效。 但是……

我们建议不要这样做：您将失去绕过实际动态组件缓存的功能。 SDI已进行全局配置，您对“贫乏 — 片段 — 缓存”所做的更改也将应用于动态组件。

我们建议您仔细研究SDI文档。 还有一些其他限制，但SDI在某些情况下是一个有价值的工具。

#### 引用

* [docs.oracle.com — 如何编写自定义JSP标签](https://docs.oracle.com/cd/E11035_01/wls100/taglib/quickstart.html)
* [Dominik Süß — 创建和使用组件过滤器](https://www.slideshare.net/connectwebex/prsentation-dominik-suess)
* [sling.apache.org - Sling Dynamic Includes](https://sling.apache.org/documentation/bundles/dynamic-includes.html)
* [helpx.adobe.com — 在AEM中设置Sling Dynamic Includes](https://helpx.adobe.com/experience-manager/kt/platform-repository/using/sling-dynamic-include-technical-video-setup.html)


#### 模型缓存

![基于模型的缓存：一个业务对象，具有两个不同的呈现](assets/chapter-3/model-based-caching.png)

*基于模型的缓存：一个业务对象，具有两个不同的呈现*

<br> 

让我们再次通过导航重新审查案例。 我们假设，每个页面都需要相同的导航标记。

但或许，情况并非如此。 您可能希望在表示&#x200B;_当前页面_&#x200B;的导航中为项目呈现不同的标记。

```
Travel Destinations

<ul class="maninnav">
  <li class="currentPage">Travel Destinations
    <ul>
      <li>Finland
      <li>Canada
      <li>Norway
    </ul>
  <li>News
  <li>About us
<ul>
```

```
News

<ul class="maninnav">
  <li>Travel Destinations
  <li class="currentPage">News
    <ul>
      <li>Winter is coming>
      <li>Calm down in the wild
    </ul>
  <li>About us
<is
```

这是两种完全不同的再现。 然而，_业务对象_ — 完整导航树 — 是相同的。  此处的&#x200B;_业务对象_&#x200B;将是表示树中节点的对象图。 该图形可以容易地存储在内存中的缓存中。 但请记住，此图形不得包含任何对象或引用您未自己创建的任何对象 — 尤其是现在的JCR节点。

#### 在浏览器中缓存

我们已经触及到在浏览器中缓存的重要性，并且有许多好的教程。 最后，对于浏览器，调度程序只是遵循HTTP协议的Web服务器。

然而，尽管有这种理论，我们已经收集了一些我们没有发现、想分享的知识。

本质上，浏览器缓存可以通过两种不同的方式使用，

1. 浏览器已缓存了一个资源，其知道确切的过期日期。 在这种情况下，它不会再次请求资源。

2. 浏览器有资源，但不确定它是否仍然有效。 在这种情况下，它将询问Web服务器（在我们的案例中是调度程序）。 如果资源自您上次提交以来已进行修改，请将其给我。 如果没有更改，则服务器以“304 — 未更改”回答，并仅传输元数据。

#### 调试

如果您正在优化Dispatcher设置以进行浏览器缓存，则在浏览器和Web服务器之间使用桌面代理服务器非常有用。 我们更喜欢卡尔·冯·兰多的《Charles Web Debugging Proxy》。

使用Charles，您可以读取与服务器传输的请求和响应。 并且 — 您可以了解有关HTTP协议的许多信息。 现代的浏览器也优惠了一些调试功能，但桌面代理的功能是前所未有的。 您可以处理传输的数据、限制传输、重放单个请求等。 用户界面布局清晰、全面。

最基本的测试是将网站用作普通用户（代理介于中间），并在静态请求（到/etc/...）的数量随时间变少时检查代理，因为这些请求应位于缓存中，不再请求。

我们发现，代理可能会给出更清晰的概述，因为缓存的请求不会显示在日志中，而某些浏览器内置调试程序仍会以“0毫秒”或“从磁盘”显示这些请求。 这是正确和准确的，但可能会给您的视图蒙上一层阴影。

然后，您可以向下展开并检查传输的文件的头，以查看(例如，如果“Expires”（过期）http头正确)。 您可以重播请求，将if-modified-since标头设置为查看服务器是否使用304或200响应代码正确响应。 您可以观察异步调用的时间，也可以在一定程度上测试您的安全假设。 是否记得我们告诉过您不接受所有不是明确预期的选择器？ 在这里，您可以玩转URL和参数，查看您的应用程序是否表现良好。

在调试缓存时，我们只要求您不要执行以下操作：

不要在浏览器中重新加载页面！

“浏览器重新加载”、_simple-reload_&#x200B;和&#x200B;_forced-reload_(&quot;_shift-reload_&quot;)与普通页面请求不同。 简单的重新加载请求设置标头

```
Cache-Control: max-age=0
```

而Shift-Reload（在单击重新加载按钮时按住Shift键）通常会设置请求标头

```
Cache-Control: no-cache
```

两个标题的效果相似但略有不同，但最重要的是，当您从URL插槽中打开URL或使用网站上的链接时，它们与普通请求完全不同。 正常浏览未设置Cache-Control头，但可能是if-modified-since头。

因此，如果要调试正常浏览行为，您应该做到：_正常浏览_。 使用浏览器的重新加载按钮是在配置中看不到缓存配置错误的最佳方式。

用查尔斯·普洛西来看看我们在说什么。 是 — 当您打开请求时，您可以在此处重播请求。 无需从浏览器重新加载。

## 性能测试

通过使用代理，您可以了解页面的时间行为。 当然，这远不是性能测试。  性能测试需要多个客户端并行请求您的页面。

我们经常看到的一个常见错误是，性能测试只包含超小数目的页面，而这些页面仅从调度程序缓存中传送。

如果要将应用程序提升到实时系统，则负载与测试的负载完全不同。

在实时系统上，访问模式并不是测试中相同分布的页面数量少(主页和内容页面少)。 页数要大得多，请求的分布也很不均匀。 而且，当然，无法从缓存中100%提供实时页面：来自发布系统的无效请求正在自动使您的大量宝贵资源失效。

是的 — 当您重建Dispatcher缓存时，您会发现，Publish系统的行为也有很大不同，具体取决于您是仅请求少量页面，还是请求的页数更大。 即使所有页面都同样复杂，页码也起到一定作用。 还记得我们说过的链式缓存吗？ 如果您始终请求相同数量的页面，则很有可能，具有原始数据的相应块位于硬盘缓存中，或者这些块由操作系统缓存。 此外，Repository很有可能已将相应区段缓存到其主内存中。 因此，重新渲染的速度比您现在将其他页面逐出并从各种缓存中逐出时要快得多。

缓存很难，对依赖于缓存的系统进行测试也是如此。 那么，你能做什么来更准确的现实场景呢？

我们认为您必须进行多个测试，并且您必须提供多个性能指标来衡量解决方案的质量。

如果您已有网站，请测量请求数以及请求的分发方式。 尝试为使用相似请求分布的测试建模。 添加一些随机性不会有害。 您不必模拟可加载JS和CSS等静态资源的浏览器 — 这些并不重要。 它们最终会缓存在浏览器或调度程序中，而且不会显着增加负载。 但引用的图像确实很重要。 在旧日志文件中查找其分发情况，并模拟类似的请求模式。

现在，请使用Dispatcher进行测试，而不是缓存。 这是你最坏的情况。 了解在最恶劣的条件下，您的系统会变得不稳定的峰值负载。 如果需要，您还可以取出一些调度程序/发布腿，从而让情况变得更糟。

接下来，对所有必需的缓存设置执行相同的测试，将其设置为“on”。 缓慢地提高并行请求，以暖化缓存并查看在这些最佳情况下您的系统可以占用多少内存。

平均情况是在启用调度程序的情况下运行测试，但也会发生一些无效。 通过使用cronjob访问statfiles或以不定期间隔向调度程序发送失效请求，可以模拟这种情况。 不要忘记时不时清除一些非自动失效的资源。

您可以通过增加失效请求和增加负载来改变上一个方案。

这比线性负载测试要复杂一些，但为您的解决方案提供了更多信心。

你可能会回避努力。 但是，在Publish系统上至少应进行最坏情况测试，页面数量较多（平均分布），以查看系统的限制。 请确保正确解释最佳案例的数量，并为系统配备足够的空间。