---
title: 第1章——教程设置和下载
seo-title: AEM Content Services入门——第1章——教程设置
description: AEM无头教程的第1章教程的AEM实例的基线设置。
seo-description: AEM无头教程的第1章教程的AEM实例的基线设置。
translation-type: tm+mt
source-git-commit: a0e5a99408237c367ea075762ffeb3b9e9a5d8eb
workflow-type: tm+mt
source-wordcount: '17502'
ht-degree: 0%

---


# 第1章——调度程序概念、模式和反模式

## 概述

本章简要介绍Dispatcher的历史和机制，并讨论这如何影响AEM开发人员设计其组件的方式。

## 为什么开发者应关注基础架构

Dispatcher是大多数(如果不是所有AEM安装)安装中必不可少的一部分。 您可以找到许多讨论如何配置Dispatcher的在线文章以及提示和技巧。

但是，这些细节信息始终在非常技术的层面上进行开始-假定您已经知道自己想做什么，因此只提供有关如何实现自己想要的细节。 我们从未找到任何概念性文 _件来描述哪些内容以及为什么_ ，当涉及到调度程序可以和不能做什么时。

### 反图案：Dispatcher的后顾之忧

缺乏基本信息导致了许多AEM项目的反模式：

1. 由于Dispatcher安装在Apache Web服务器中，因此它是项目中“Unix gods”的作业来配置它。 “凡人的java开发者”不需要关心它。

2. Java开发人员需要确保其代码工作……调度程序稍后将神奇般地加快速度。 调度程序始终是后顾之忧。 但是，这不起作用。 开发人员必须在设计代码时考虑到调度程序。 他需要知道它的基本概念。

### “先让它起作用，然后让它快速起作用”不总是正确

你可能听到过编程 _建议：“先让它起作用，然后让它快速起作用。”_. 这并非完全错误。 但是，如果没有正确的上下文，则往往会被错误解释，并且无法正确应用。

建议应防止开发人员过早优化代码，这些代码可能永远不会运行，或者极少运行，以至于优化不会产生足够的影响，从而证明将投入优化的努力是合理的。 此外，优化可导致更复杂的代码，从而引入缺陷。 因此，如果您是开发者，请不要花太多时间对每一行代码进行微优化。 只需确保您选择了正确的分析结构、算法和库，然后等待概要分析器的热点，了解更彻底的优化可以提高整体性能。

### 建筑决策和文物

然而，在“建筑”决策方面，“先让它起作用，然后让它快速起作用”的建议是完全错误的。 什么是建筑决策？ 简言之，它们是代价高昂、困难和／或不可能事后改变的决定。 请记住，“昂贵”有时与“不可能”相同。  例如，当您的项目预算不足时，就无法实施昂贵的更改。 基础设施的改变是大多数人想到的类别中第一种改变。 但还有另一种“建筑”艺术品，它们可能变得非常讨厌：

1. 应用程序“中心”的代码片段，许多其他片段都依赖它。 更改这些属性，要求立即更改和重新测试所有依赖关系。

2. 在一些异步、与时间相关的场景中，会出现不自然现象，因此，系统的行为可能会非常随机地发生变化。 更改可能产生不可预知的效果，并且很难测试。

3. 在系统的所有部分和部分反复使用和重复使用的软件模式。 如果软件模式被证明是次优的，则需要重新编码使用该模式的所有伪像。

记住? 在本页顶部，我们说调度程序是AEM应用程序的一个基本部分。 访问Web应用程序是非常随机的——用户来来去往的时间不可预知。 最后——所有内容将（或应）缓存到调度程序中。 因此，如果您非常关注缓存，您可能已经意识到缓存可以被视为“建筑”工具，因此应该被团队的所有成员、开发人员和管理员所理解。

我们并不是说开发人员应实际配置Dispatcher。 他们需要了解相关概念，特别是边界，以确保调度程序也能利用其代码。

调度程序不会神奇地提高代码速度。 开发人员需要在创建组件时牢记Dispatcher。 因此，他需要知道它是如何工作的。

## 调度程序缓存——基本原则

### 作为缓存Http的调度程序——负载平衡器

什么是调度程序，为什么最初称为“调度程序”?

调度程序

* 首先也是最重要的缓存

* 反向代理

* 用于Apache httpd webserver的模块，将AEM相关功能添加到Apache的通用性中，并与所有其他Apache模块（如SSL甚至SSI，如我们稍后将看到的）顺利协作

在Web发布初期，您会期望有几百个访客访问网站。 一个调度程序的设置，“已调度”或平衡对多个AEM发布服务器的请求负载，这通常是足够的，因此名称为“Dispatcher”。 但是，现在这种设置已不常使用。

本文后面将介绍设置调度程序和发布系统的不同方法。 首先，让我们开始一些HTTP缓存基础知识。

![调度程序缓存的基本功能](assets/chapter-1/basic-functionality-dispatcher.png)

*调度程序缓存的基本功能*

<br> 

此处介绍了调度程序的基本知识。 调度程序是一个简单的缓存反向代理，能够接收和创建HTTP请求。 正常的请求／响应周期如下：

1. 用户请求页面
2. 调度程序会检查它是否已具有该页面的渲染版本。 假设它是此页面的第一个请求，调度程序找不到本地缓存副本。
3. 调度程序从发布系统请求该页面
4. 在发布系统中，页面由JSP或HTL模板呈现
5. 该页将返回给调度程序
6. 调度程序缓存该页
7. 调度程序将页面返回到浏览器
8. 如果再次请求同一页，则可以直接从调度程序缓存中提供该页，无需在Publish实例中重新渲染它。 这节省了用户和CPU循环在Publish实例上的等待时间。

我们在最后一节讨论“页面”。 但同样的方案也适用于其他资源，如图像、CSS文件、PDF下载等。

#### 数据缓存方式

调度程序模块利用托管Apache服务器提供的设施。 资源（如HTML页、下载和图片）作为简单文件存储在Apache文件系统中。 就是这么简单。

文件名由所请求资源的URL派生。 如果请求文件， `/foo/bar.html` 它将存储在例如／下`var/cache/docroot/foo/bar.html`。

原则上，如果所有文件都已缓存并因此在Dispatcher中静态存储，您可以拔出Publish系统的插件，而Dispatcher将充当一个简单的Web服务器。 但这只是为了说明这个原则。 现实生活更复杂。 由于渲染过程的动态性质，资源数量可能是无限的，因此您无法缓存所有内容，而且缓存从来不是完全“完全”的。 静态文件系统的模型有助于生成调度程序功能的大致图景。 它有助于解释调度程序的局限性。

#### AEM URL结构与文件系统映射

要更详细地了解调度程序，让我们重新访问简单示例URL的结构。  下面我们来看一个例子，

`http://domain.com/path/to/resource/pagename.selectors.html/path/suffix.ext?parameter=value&amp;otherparameter=value#fragment`

* `http` 表示协议

* `domain.com` 是域名

* `path/to/resource` 是资源存储在CRX中的路径，随后存储在Apache服务器的文件系统中

从这里看，AEM文件系统和Apache文件系统之间的情况略有不同。

在AEM,

* `pagename` 是资源标签

* `selectors` 表示Sling中使用的许多选择器，用于确定资源的呈现方式。 URL可以具有任意数量的选择器。 他们隔了一段时间。 例如，选择器部分可以是“french.mobile.fancy”。 选择器应仅包含字母、数字和虚线。

* `html` 作为最后一个“选择器”称为扩展。 在AEM/Sling中，它还部分决定了渲染脚本。

* `path/suffix.ext` 是类似于路径的表达式，可以作为URL的后缀。  它可用于AEM脚本中，以进一步控制资源的呈现方式。 稍后我们将提供有关此部分的整个部分。 目前，您应该已经知道，您可以将其用作其他参数。 后缀必须有扩展名。

* `?parameter=value&otherparameter=value` 是URL的查询部分。 它用于将任意参数传递给AEM。 无法缓存带参数的URL，因此，参数应限制为绝对必要的情况。

* `#fragment`, URL的片段部分不会传递给AEM，而只在浏览器中使用；在JavaScript框架中作为“路由参数”或跳到页面上的某个部分。

在Apache中(*参考下图*),

* `pagename.selectors.html` 用作缓存文件系统中的文件名。

如果URL有后缀 `path/suffix.ext` ,

* `pagename.selectors.html` 创建为文件夹

* `path` 文件夹中的文 `pagename.selectors.html` 件夹

* `suffix.ext` 是文件夹中的文 `path` 件。 注意：如果后缀没有扩展名，则不缓存文件。

![从调度程序获取URL后的文件系统布局](assets/chapter-1/filesystem-layout-urls-from-dispatcher.png)

*从调度程序获取URL后的文件系统布局*

<br> 

#### 基本限制

URL、资源和文件名之间的映射非常简单。

你可能注意到一些陷阱，

1. URL可能变长。 在本地文件系统上添加“路 `/docroot` 径”部分可能很容易超出某些文件系统的限制。 在Windows上的NTFS中运行调度程序可能是个难题。 但Linux是安全的。

2. URL可包含特殊字符和变音。 对于调度程序来说，这通常不是问题。 但是，请记住，URL会在应用程序的许多位置进行解释。 我们经常看到应用程序的奇怪行为——只是为了发现一个很少使用（自定义）的代码没有经过对特殊字符的彻底测试。 如果可以的话，你应该避开他们。 如果不能，请计划进行彻底测试。

3. 在CRX中，资源具有子资源。 例如，页面将具有多个子页面。 在文件系统中无法匹配此项，因为文件系统具有文件或文件夹。

#### 未缓存无扩展名的URL

URL始终必须具有扩展名。 尽管您可以在AEM中提供不带扩展的URL。 这些URL将不会在调度程序中缓存。

**示例**

`http://domain.com/home.html` 是可 **缓存**

`http://domain.com/home` 无 **法缓存**

当URL包含后缀时，同样的规则也适用。 后缀需要有可缓存的扩展。

**示例**

`http://domain.com/home.html/path/suffix.html` 是可 **缓存**

`http://domain.com/home.html/path/suffix` 无 **法缓存**

您也许会问，如果资源部分没有扩展，但后缀有扩展，会发生什么情况？ 那么，在这种情况下，URL根本就没有后缀。 请看下一个示例：

**示例**

`http://domain.com/home/path/suffix.ext`

该 `/home/path/suffix` 是资源的路径……，因此URL中没有后缀。

**结论**

始终为路径和后缀添加扩展。 了解SEO的人有时会辩称，这在搜索结果中排名靠后。 但是，未缓存的页面速度会非常慢，排名会更低。

#### 后缀URL冲突

请考虑您有两个有效的URL

`http://domain.com/home.html`

和

`http://domain.com/home.html/suffix.html`

它们在AEM绝对有效。 在本地开发机器上（没有调度程序），您不会发现任何问题。 在UAT或负载测试中，您很可能也不会遇到任何问题。 我们面临的问题非常微妙，以至于它在大多数测试中都漏掉了。  在高峰时段，它会给您带来沉重的打击，并且您将受到时间限制来解决它，可能没有服务器访问权，也没有资源来修复它。 我们去过……

那，有什么问题？

`home.html` 文件系统中可以是文件或文件夹。 不是和AEM同时存在。

如果您先 `home.html` 申请，它将创建为文件。

后续请求 `home.html/suffix.html` 返回有效结果，但由于文件 `home.html` “阻止”文件系统中的位置，因此不能再 `home.html` 次创建一个文件夹，因此不 `home.html/suffix.html` 进行缓存。

![文件系统中阻止子资源缓存的文件阻止位置](assets/chapter-1/file-blocking-position-in-filesystem.png)

*文件系统中阻止子资源缓存的文件阻止位置*

<br> 

如果以相反的方式进行，则首先请求， `home.html/suffix.html` 然 `suffix.html` 后首先在文件夹 `/home.html` 下缓存。 但是，当您随后作为资源请求时，此文 `home.html` 件夹将被删除 `home.html` 并替换为文件。

![将父项作为资源读取时删除路径结构](assets/chapter-1/deleting-path-structure.png)

*将父项作为资源读取时删除路径结构*

<br> 

因此，缓存内容的结果完全是随机的，取决于传入请求的顺序。 更棘手的是，您通常拥有多个调度程序。 性能、缓存命中率和行为可能因调度程序的不同而异。 如果要了解您的网站为何没有响应，您需要确保查看的调度程序正确且缓存顺序不正确。 如果您正在寻找具有更有利请求模式的调度程序，那么您将迷失于寻找该问题。

#### 避免冲突的URL

当您对资源使用不同扩展名时，您可以避免“冲突的URL”，因为文件系统中的同一路径的文件夹名称和文件名“竞争”。

**示例**

* `http://domain.com/home.html`

* `http://domain.com/home.dir/suffix.html`

两者都完全可以连接，

![](assets/chapter-1/cacheable.png)

在请求后缀或避免完全使用后缀时，为资源选择专用扩展“dir”。 在很少的情况下，它们是有用的。 这些情况易于正确实施。  正如我们在下一章中讨论缓存失效和刷新时所看到的。

#### 不可处理的请求

让我们来简单回顾一下最后一章的概要以及一些其他例外情况。 如果URL被配置为可缓存且是GET请求，则调度程序可以缓存该URL。 无法在以下异常之一下缓存它。

**可缓存请求**

* 请求配置为在调度程序配置中可缓存
* 请求是纯GET请求

**不可缓存的请求或响应**

* 按配置拒绝缓存的请求（路径、模式、MIME类型）
* 返回“调度程序：no cache&quot;头
* 返回“缓存控制：no-cache|private&quot;头
* 返回“Pragma:no cache&quot;头
* 具有查询参数的请求
* 无扩展名的URL
* 带后缀且没有扩展名的URL
* 返回200以外的状态代码的响应
* POST请求

## 缓存失效和刷新

### 概述

最后一章列出了当调度程序无法缓存请求时的大量异常。 但还有更多事情需要考虑：仅仅因为Dispatcher _可以缓_ 存请求，它不一定表示它应 _该_。

重点是：缓存通常很容易。 调度程序只需存储响应的结果，并在下次收到相同的请求时返回。 右? 错了！

难点在于缓 _存的__失效_ 或刷新。 调度程序需要了解资源何时发生更改，并需要重新渲染。

乍一看，这似乎是微不足道的任务.....但事实并非如此。 进一步阅读，您会发现单一资源和简单资源以及依赖高度网状多资源结构的页面之间的一些棘手差异。

### 简单资源和刷新

我们已设置AEM系统，以在通过特殊的“缩略图”选择器提出请求时动态为每个图像创建缩略图再现：

`/content/dam/path/to/image.thumb.png`

当然，我们还会提供一个URL，用一个无选择器的URL来提供原始图像：

`/content/dam/path/to/image.png`

如果我们同时下载缩略图和原始图像，我们会得到类似的结果，

```
/var/cache/dispatcher/docroot/content/dam/path/to/image.thumb.png

/var/cache/dispatcher/docroot/content/dam/path/to/image.png
```

调度程序的文件系统。

现在，用户上传并激活该文件的新版本。 最终，失效请求从AEM发送到调度程序，

```
GET /invalidate
invalidate-path:  /content/dam/path/to/image

<no body>
```

失效很简单：对调度程序上特殊“/invalidate”URL的简单GET请求。 不需要HTTP-body,“payload”只是“invalidate-path”头。 另请注意，标头中的invalidate-path是AEM所知的资源，而不是调度程序已缓存的文件。 AEM只知道资源。 请求资源时，在运行时使用扩展、选择器和后缀。 AEM不对资源上使用的选择器执行任何记账操作，因此资源路径是它在激活资源时确定的所有资源路径。

就我们而言，这就足够了。 如果某个资源已更改，我们可以安全地假定该资源的所有演绎版也已更改。 在我们的示例中，如果图像已更改，则还将渲染新的缩略图。

调度程序可以安全地删除其已缓存的所有演绎版的资源。 它会做些什么，

`$ rm /content/dam/path/to/image.*`

删除 `image.png` 和所 `image.thumb.png` 有与该模式匹配的其他演绎版。

非常简单的确……只要您只使用一个资源来响应请求。

### 参照和网格化内容

#### 网格化内容问题

与上传到AEM的图像或其他二进制文件不同，HTML页面不是孤立的动物。 它们生活在群组中，通过超链接和引用高度相互关联。 简单的链接是无害的，但是当我们讨论内容引用时，它会变得棘手。 页面上无处不在的顶部导航或Teaser是内容引用。

#### 内容引用及其成为问题的原因

让我们看一个简单的例子。 旅行社有网页，宣传前往加拿大的旅行。 此促销活动在另外两个页面的Teaser部分、“主页”页面和“Winter Specials”页面中提供。

由于两个页面都显示相同的Teaser，因此不必要求作者为应显示它的每个页面多次创建Teaser。 相反，目标页面“加拿大”保留页面属性中的一个部分以提供Teaser的信息，或者更好地提供渲染该Teaser的URL:

`<sling:include resource="/content/home/destinations/canada" addSelectors="teaser" />`

或

`<sling:include resource="/content/home/destinations/canada/jcr:content/teaser" />`

![](assets/chapter-1/content-references.png)

在AEM上，它只能像魅力一样工作，但如果您在Publish实例上使用调度程序，就会发生奇怪的情况。

想象一下，您发布了您的网站。 您的加拿大页面上的标题为“Canada”。 当访客请求您的主页时（该具有对该页面的Teaser引用）,“加拿大”页面上的组件会呈现类似

```
<div class="teaser">
  <h3>Canada</h3>
  <img …>
</div>
```

*进入* 主页。 主页由调度程序以静态。html文件形式存储，包括Teaser，它在文件中是标题。

营销人员已了解到，Teaser标题应具有可操作性。 因此，他决定将标题从“加拿大”改为“访问加拿大”，并更新图像。

他发布经过编辑的“加拿大”页面，并重新访问之前发布的主页，查看他所做的更改。 但是，那里没有什么变化。 它仍显示旧的Teaser。 他多次检查“冬季特惠”。 以前从未请求过该页面，因此不会在调度程序中静态缓存该页面。 因此，此页面由“发布”新呈现，并且此页面现在包含新的“访问加拿大”Teaser。

![在主页中存储陈旧内容的调度程序](assets/chapter-1/dispatcher-storing-stale-content.png)

*在主页中存储陈旧内容的调度程序*

<br> 

怎么了？ 调度程序存储页面的静态版本，该版本包含呈现时从其他资源绘制的所有内容和标记。

调度程序只是一个基于文件系统的Web服务器，速度快，但也相对简单。 如果包含的资源发生更改，它不会意识到这一点。 呈现包含页面时的内容仍然保留。

“冬季特殊”页面尚未呈现，因此调度程序上没有静态版本，因此将随新Teaser一起显示，因为它将在请求时新呈现。

您可能认为，当资源发生更改时，调度程序会在渲染和刷新已使用此资源的所有页面时跟踪它访问的每个资源。 但调度程序不呈现页面。 渲染由发布系统执行。 调度程序不知道渲染后的。html文件中将包含哪些资源。

还是不相信？ 您可能认 *为“必须有一种方法来实施某种依赖性跟踪”*。 有，或者更准确的 *是*。 公报三，AEM的曾曾曾祖父在会议上实施了一个依赖追踪 _器_ ，用于翻页。

在请求期间，通过此会话获取的每个资源都会作为当前呈现的URL的依赖项进行跟踪。

但事实证明，跟踪这些依赖项非常昂贵。 人们很快发现，如果完全关闭依赖项跟踪功能，并且依赖于在一个html页面发生更改后重新渲染所有html页面，则网站的速度会更快。 此外，这一方案也不完美——在路上有许多陷阱和例外。 在某些情况下，您不是使用请求默认会话来获取资源，而是使用管理员会话来获取一些帮助资源来呈现请求。 这些依赖关系通常未被跟踪，并导致头痛，并且需要给运营团队打电话请求手动刷新缓存。 如果他们有标准的手术，你就很幸运了。 路途上还有更多的迷路，但是……让我们停止追忆吧。 这样可以追溯到2005年。 最终，这一功能在公报4中被默认取消激活，但它并未让它回到后续的CQ5中，CQ5随后成为AEM。

### 自动失效

#### 当完全刷新比依赖跟踪更便宜时

由于CQ5，只有其中一个页面发生更改，我们或多或少都依赖于整个站点的失效。 此功能称为“自动失效”。

但是，抛弃和重新渲染数百页比进行适当的依赖跟踪和部分重新渲染更便宜，这又怎么可能呢？

原因有二：

1. 在平均网站中，只经常请求一小部分页面。 因此，即使您扔掉所有渲染的内容，实际上在之后只会立即请求几十个。 页面长尾的呈现可以随着时间的推移而分发，当实际请求时。 因此，实际上，渲染页面上的负载没有您预期的那么高。 当然，总有例外……稍后，我们将讨论一些技巧，如何在具有空调度程序缓存的较大网站上处理均匀分布的负载。

2. 所有页面仍由主导航连接。 因此，几乎所有页面最终都是相互依赖的。 这意味着，即使是最聪明的依赖追踪器也会发现我们已经知道的：如果其中一个页面发生更改，则必须使所有其他页面失效。

你不相信？ 让我们来说明最后一点。

我们使用的参数与上一个示例中的参数相同，Teaser引用到远程页面的内容。 直到现在，我们还用一个更极端的例子：自动呈现的主导航。 与Teaser一样，导航标题从链接的或“远程”页面中作为内容引用来绘制。 远程导航标题不存储在当前呈现的页面中。 您应该记住，导航会呈现在网站的每个页面上。 因此，在具有主导航的所有页面上，将一遍又一遍地使用一个页面的标题。 如果要更改导航标题，则只希望在远程页面上执行一次，而不是在引用该页面的每个页面上执行此操作。

因此，在我们的示例中，导航使用目标页面的“NavTitle”在导航中呈现名称，从而将所有页面网格化在一起。 “冰岛”的导航标题从“冰岛”页面中提取，并呈现到具有主导航的每个页面中。

![主导航通过拖动其“NavTitles”不可避免地将所有页面的内容相互划分](assets/chapter-1/nav-titles.png)

*主导航通过拖动其“NavTitles”不可避免地将所有页面的内容相互划分*

<br> 

如果您将冰岛页面上的NavTitle从“Icelanda”更改为“Beutiful Icelanda”，则标题会立即在所有其他页面的主菜单中发生变化。 因此，在更改之前呈现和缓存的页面会变得陈旧，并且需要使其失效。

#### 自动失效的实现方式：.stat文件

现在，如果您有一个包含数千个页面的大型网站，则需要花费相当长的时间循环浏览所有页面并实际删除它们。 在此期间，调度程序可能会无意中提供过时的内容。 更糟糕的是，在访问缓存文件时可能会发生一些冲突，可能在页面被删除时请求页面，或由于立即后续激活后发生的第二次失效而再次删除页面。 想想会是多么混乱。 幸运的是，事情并非如此。 调度程序使用巧妙的技巧来避免：在文件发布时，它不会删除成千上万个文件，而是将一个简单的空文件放入文件系统的根文件中，因此所有依赖的文件都被认为是无效的。 此文件称为“statfile”。 statfile是空文件——与statfile相关的只是其创建日期。

调度程序中创建日期早于statfile的所有文件都已在上次激活（和失效）之前呈现，因此被视为“无效”。 它们在文件系统中仍然存在，但调度程序会忽略它们。 他们“过时”了。 只要对旧资源发出请求，调度程序就会要求AEM系统重新渲染页面。 新呈现的页面随后会存储在文件系统中——现在有一个新的创建日期，它又重新出现。

![.stat文件的创建日期定义哪些内容过时和新鲜](assets/chapter-1/creation-date.png)

*.stat文件的创建日期定义哪些内容过时和新鲜*

<br> 

您可能会问为什么它称为“.stat”? 也许不是“.unvalided”? 您可以想象，将该文件放在您的文件系统中可帮助调度程序确定哪些资源可 *以静态* 提供——就像从静态Web服务器一样。 这些文件不再需要动态呈现。

然而，这个名字的真正本质并不是暗喻。 它从Unix系统调用中派生， `stat()`该调用返回文件的修改时间（其他属性中）。

#### 将简单验证与自动验证相结合

但等等……我们之前说过，单个资源被物理删除。 现在，我们说，在调度程序的眼中，一个更新的statfile实际上会使它们无效。 那为什么首先进行物理删除？

答案很简单。 您通常将两种策略并行使用——但对于不同的资源。 二进制资源，如图像是自包含的。 它们与其他资源之间没有联系，这意味着它们需要呈现其信息。

而HTML页面则高度相互依赖。 因此，您会对这些应用自动失效。 这是调度程序中的默认设置。 属于无效资源的所有文件将被物理删除。 此外，以“.html”结尾的文件会自动失效。

调度程序决定是否应用自动失效方案。

可配置自动失效的文件结尾。 理论上，您可以包含自动失效的所有扩展。 但是请记住，这是一个非常高的代价。 您不会无意中交付过时的资源，但投放性能会因过度失效而大幅降低。

例如，您实施了一种方案，其中PNG和JPG动态渲染并依赖其他资源进行渲染。 您可能希望将高分辨率图像重新缩放为较小的Web兼容分辨率。 当您处于该状态时，还可以更改压缩率。 此示例中的分辨率和压缩率不是固定常量，而是使用图像的组件中的可配置参数。 现在，如果此参数已更改，则需要使图像失效。

没问题——我们刚刚学到，我们可以将图像添加到自动失效中，并且每当发生任何变化时，都会有新呈现的图像。

#### 《把婴儿和洗澡水一起扔掉》

这是对的——这是个大问题。 再次阅读最后一段。 “...只要有任何变化，就新呈现的图像。” 如您所知，一个好网站不断变化；在此处添加新内容，在此纠正打字错误，在其他地方调整teaser。 这意味着您的所有图像会不断失效，需要重新渲染。 别低估了。 在本地开发机器上，动态渲染和传输图像数据的工作时间只需几毫秒。 您的生产环境需要更频繁地完成此操作——每秒。

让我们在此处清楚一下，当html页面发生更改时，需要重新渲染您的jpg，反之亦然。 只有一个“存储段”可自动失效。 它整体上是冲的。 没有办法进一步细化结构。

默认情况下，自动失效保留为“.html”有充分的理由。 目标是尽量把那桶水小一点。 不要把婴儿和洗澡水一起扔出去，只是让一切都失效——只是为了站在安全的一边。

独立资源应该按照该资源的路径提供服务。 这对失效有很大帮助。 保持简单，不要创建映射方案，如“resource /a/b/c”从“/x/y/z”提供。 使您的组件能够使用默认的调度程序自动失效设置。 请勿尝试在调度程序中修复设计错误且失效过度的组件。

##### 自动失效例外：仅资源失效

调度程序的失效请求通常由复制代理从发布系统触发。

如果您对依赖关系非常有信心，可以尝试构建自己的失效复制代理。

要了解详细信息，本指南可能有些不足，但我们想至少给您一些提示。

1. 真正了解您在做什么。 要正确行使失效真的很困难。 这就是汽车失效如此严格的原因之一；避免交付陈旧内容。

2. 如果代理发送HTTP头， `CQ-Action-Scope: ResourceOnly`则表示此单个失效请求不会触发自动失效。 此( [https://github.com/cqsupport/webinar-dispatchercache/tree/master/src/refetching-flush-agent/refetch-bundle](https://github.com/cqsupport/webinar-dispatchercache/tree/master/src/refetching-flush-agent/refetch-bundle))代码可能是您自己的复制代理的一个好起点。

3. `ResourceOnly`，仅防止自动失效。 要实际执行必要的依赖关系解析和失效验证，您必须自己触发失效请求。 您可能希望检查包Dispatcher刷新规则([https://adobe-consulting-services.github.io/acs-aem-commons/features/dispatcher-flush-rules/index.html](https://adobe-consulting-services.github.io/acs-aem-commons/features/dispatcher-flush-rules/index.html))，以了解该规则的实际发生方式。

我们不建议您构建依赖性解析方案。 我们付出了太多努力，收益也微乎其微——正如之前所说，你错得太多了。

相反，您应该了解哪些资源不依赖于其他资源，并且可以在不自动失效的情况下失效。 但是，您不必为此使用自定义复制代理。 只需在调度程序配置中创建一个自定义规则，该规则将这些资源排除在自动失效之外。

我们说主导航或Teaser是依赖关系的源。 好吧——如果您异步加载导航和Teaser，或将它们包含在Apache中的SSI脚本中，您就没有要跟踪的依赖关系。 我们将在本文档稍后讨论“Sling Dynamic Includes”时详细介绍异步加载组件。

弹出窗口或加载到Lightbox中的内容也是如此。 这些片段也很少具有导航（亦即“依赖关系”），并可作为单个资源失效。

## 在构建组件时牢记调度程序

### 调度机理在实际案例中的应用

在最后一章中，我们介绍了Dispatcher的基本机制、它的一般工作方式以及限制。

现在，我们将这些力学应用到您很可能在项目要求中找到的一类元件。 我们故意选择组件，以展示您迟早也会面临的问题。 不要害怕——并非所有要素都需要我们提供的这种考虑。 但是，如果您看到构建这样一个组件的必要性，您会清楚地意识到后果并知道如何处理。

### 假脱机组件（防）图案

#### 响应式图像组件

让我们说明具有互连二进制文件的组件的通用模式（或反模式）。 我们将创建“响应”组件——用于“响应式图像”。 此组件应能够将显示的图像调整为其显示的设备。 在台式机和平板电脑上，它显示图像的全分辨率，在手机上以较小的版本显示图像——甚至可能是完全不同的主题（在响应式世界中，这称为“艺术方向”）。

资产上传到AEM的DAM区域，并且仅在响 _应式图_ 像组件中引用了这些资产。

响应组件负责标记的呈现和二进制图像数据的传送。

我们在这里实施它的方式是我们在许多项目中看到的一个共同模式，甚至AEM核心组件之一都基于该模式。 因此，作为开发者，您很有可能会改变这种模式。 在封装方面，它有其最佳点，但要使其具备Dispatcher就绪性，它需要付出大量努力。 我们稍后将讨论几种减轻问题的方法。

我们把这里使用的模式称为“假新闻模式”，因为问题可以追溯到公报3的早期，当时有一种方法可以被称为“假新闻”，用资源将二进制原始数据流化到响应中。

原始术语“假脱机”实际上是指共享的慢速脱机外围设备，如打印机，因此在此处无法正确应用它。 但我们还是喜欢这个词，因为在网络世界中，这个词很少被区分。 而且每种模式都应该有一个可辨别的名称，对吧？ 这取决于你是否是一种模式或反模式。

#### 实施

下面介绍如何实现响应式图像组件：

该构件分为两部分：第一部分呈现图像的HTML标记，第二部分“假脱机”引用的图像的二进制数据。 由于这是一个具有响应式设计的现代网站，因此我们不渲染简单的标 `<img src"…">` 签，而是渲染标签中的一组 `<picture/>` 图像。 对于每台设备，我们会将两个不同的图像上传到DAM，并从我们的图像组件中引用它们。

该组件具有三个渲染脚本（在JSP、HTL中实现，或作为servlet实现），每个脚本都使用专用选择器来解决：

1. `/respi.jsp` -没有用于呈现HTML标记的选择器
2. `/respi.img.java` 渲染桌面版本
3. `/respi.img.mobile.java` 来渲染移动版本。


该组件位于主页的parsys中。 CRX中的结果结构如下所示。

![CRX中响应式图像的资源结构](assets/chapter-1/responsive-image-crx.png)

*CRX中响应式图像的资源结构*

<br> 

组件标记呈现如下，

```plain
  #GET /content/home.html

  <html>

  …

  <div class="responsive-image>

  <picture>
    <source src="/content/home/jcr:content/par/respi.img.mobile.jpg" …/>
    <source src="/content/home/jcr:content/par/respi.img.jpg …/>

    …

  </picture>
  </div>
  …
```

我们用封装精良的组件完成了。

#### 响应式图像组件的实际操作情况

现在，用户通过调度程序请求页面和资产。 这会导致调度程序文件系统中的文件，如下所示，

![封装的响应式图像组件的高速缓存结构](assets/chapter-1/cached-structure-encapsulated-image-comonent.png)

*封装的响应式图像组件的高速缓存结构*

<br> 

考虑用户上传并将两个花卉图像的新版本激活到DAM。 AEM将根据失效请求发送

`/content/dam/flower.jpg`

和

`/content/dam/flower-mobile.jpg`

调度程序。 然而，这些要求是徒劳的。 内容已缓存为组件子结构下的文件。 这些文件现已过时，但仍会按请求提供。

![导致内容过时的结构不匹配](assets/chapter-1/structure-mismatch.png)

*导致内容过时的结构不匹配*

<br> 

这一方法还有另外一个警告。 请考虑在多个页面上使用相同的flower.jpg。 然后，您将在多个URL或文件下缓存同一资产，

```
/content/home/products/jcr:content/par/respi.img.jpg

/content/home/offers/jcr:content/par/respi.img.jpg

/content/home/specials/jcr:content/par/respi.img.jpg

…
```

每次都会请求一个新的、未缓存的页面，从AEM中以不同的URL获取资产。 没有调度程序缓存和浏览器缓存可以加快投放。

#### 假脱机模式放光的地方

有一个自然的例外，即使以简单的形式，这种模式也是有用的：如果二进制文件存储在组件本身中，而不是存储在DAM中。 但是，此功能仅对在网站上使用过一次的图像有用，而不将资产存储在DAM意味着您很难管理资产。 只需想象您针对特定资产的使用许可证已用完。 您如何找到已使用资产的组件？

你看？ DAM中的“M”代表“管理”，就像在数字资产管理中一样。 你不想把那个特征泄露出去。

#### 结论

从AEM开发者的角度看，这种模式看起来非常优雅。 但是，如果调度程序考虑到这个等式，你可能会同意，天真的方法可能是不够的。

现在，由您决定这是一种模式还是一种反模式。 也许您已经有了一些好的想法，想如何减轻上述问题？ 很好。 那么，你将迫切地想知道其他项目是如何解决这些问题的。

### 解决常见调度程序问题

#### 概述

我们来讨论一下如何能够更方便地实现缓存友好性。 有多种选择。 有时，您无法选择最佳解决方案。 可能您遇到一个已在运行的项目，并且您的预算有限，只能解决手头的“缓存问题”，而且不足以进行完全重构。 或者您遇到一个问题，这比示例图像组件更复杂。

我们将在以下几节中概述这些原则和注意事项。

同样，这是基于现实体验的。 我们已经看到了所有的野外模式，所以这不是学术活动。 这就是为什么我们给你展示一些反模式，因此你有机会从别人已经犯的错误中吸取教训。

#### 高速缓存杀手

>[!WARNING]
>
>这是反模式。 不要使用它。 永远。

你见过查询参数吗 `?ck=398547283745`? 它们称为高速缓存杀手(“ck”)。 其思想是，如果添加任何查询参数，则不会调用资源。 此外，如果添加随机数作为参数值（如“398547283745”），则URL将变得唯一，并确保AEM系统和屏幕之间没有任何其他缓存能够缓存。 通常的中间可疑是调度程序、CDN甚至浏览器缓存前的“清漆”缓存。 同样：别这样。 您确实希望尽可能长地缓存您的资源。 缓存是您的朋友。 别杀朋友。

#### 自动失效

>[!WARNING]
>
>这是反模式。 避免将其用于数字资产。 请尝试保留Dispatcher的默认配置，该配置>对于“.html”文件为自动失效，仅限

短期而言，您可以向调度程序中的自动失效配置添加“.jpg”和“.png”。 这意味着，每当出现失效时，都需要重新呈现所有“.jpg”、“.png”和“.html”。

如果企业主抱怨他们的更改在实时站点上实现的速度不够快，则这种模式非常容易实现。 但这只能给你一些时间，让你得出一个更复杂的解决方案。

确保您了解对性能的巨大影响。 这将显着降低网站速度，甚至可能影响网站的稳定性（如果网站是高负载网站且频繁更改），例如新闻门户。

#### URL指纹

URL指纹看起来像是缓存杀手。 但事实并非如此。 它不是随机数，而是表示资源内容的值。 这可以是资源内容的哈希值，也可以是上传、编辑或更新资源时的时间戳。

Unix时间戳足够用于实际实施。 为了更好的可读性，我们在本教程中使用一种更易读的格式： `2018 31.12 23:59 or fp-2018-31-12-23-59`.

指纹不能用作查询参数，因为无法缓存具有查询参数的URL。 您可以对指纹使用选择器或后缀。

假设，档案的日 `/content/dam/flower.jpg` 期是 `jcr:lastModified` 2018年12月31日，23:59。 指纹的URL为 `/content/home/jcr:content/par/respi.fp-2018-31-12-23-59.jpg`。

只要引用的资源()文件没有更改，此URL`flower.jpg`就保持稳定。 因此，它可以无限期地缓存，而且它不是缓存杀手。

注意，此URL需要由响应式图像组件创建并提供。 它不是现成的AEM功能。

这是基本概念。 然而，有些细节很容易被忽视。

在我们的示例中，组件在23:59渲染并缓存。 现在图像已经更改，假设00:00。  该组 _件将_ 在其标记中生成新的指纹URL。

你也许觉 _得_，但不是。由于只更改了图像的二进制文件，并且未触及包含页面，因此无需重新渲染HTML标记。 因此，调度程序使用旧指纹为页面提供服务，从而提供旧版图像。

![图像组件比引用的图像更新，无需渲染新的指纹。](assets/chapter-1/recent-image-component.png)

*图像组件比引用的图像更新，无需渲染新的指纹。*

<br> 

现在，如果您重新激活了主页（或该站点的任何其他页面），将更新statfile，调度程序将考虑home.html过时，并在图像组件中使用新指纹重新渲染它。

但我们没有激活主页，对吧？ 为什么我们应该激活一个未触及它的页面？ 此外，我们可能没有足够的权限激活页面，或者审批工作流如此漫长而耗时，以至于我们无法在短时间内进行激活。 那么，该怎么办？

#### 懒惰管理员的工具——降低状态文件级别

>[!WARNING]
>
>这是反模式。 只在短期内使用它来赢得一些时间，并想出更复杂的解决方案。

懒惰管理员通常“_将自动失效设置为jpgs，将statfile级别设置为零——这始终有助于缓存各种类型的问题_。” 在科技论坛上，您会发现这一建议，它有助于解决您的无效问题。

直到现在，我们还没有讨论静态文件级别。 基本上，自动失效仅适用于同一子树中的文件。 但问题是，页面和资产通常不位于同一子树中。 页面位于下方，而 `/content/mysite` 资产位于下方 `/content/dam`。

“statfile level”定义子树的根节点在什么深度处。 在以上示例中，级别为“2”(1=/content, 2=/mysite,dam)

将statfile级别“降低”到0的想法基本上是将整个/content树定义为一个子树，并仅将页面和资产置于同一自动失效域中。 因此，我们只能在大树上进行分级（在docroot“/”）。 但是，只要发布某些内容，即使在完全无关的网站上，也会自动使服务器上的所有站点失效。 相信我们：从长远来看，这是个坏主意，因为您会严重降低整个缓存命中率。 您只能希望AEM服务器拥有足够的火力，无需缓存即可运行。

稍后您将了解更深入的静态文件级别的全部优势。

#### 实现自定义失效代理

总之，如果“.jpg”或“.png”更改为允许使用新URL重新渲染，我们需要告诉调度程序使HTML页失效。

我们在项目中看到的是，例如，发布系统上的特殊复制代理，每当发布站点的映像时，都会发送站点的失效请求。

在此，如果您可以通过命名约定从资产的路径派生站点的路径，那么这对您有很大帮助。

通常，最好匹配站点和资产路径，如下所示：

**示例**

```
/content/dam/site-a
/content/dam/site-b

/content/site-a
/content/site-b
```

这样，在/content/site-a遇到更改时，您的自定义调度程序刷新代理可以轻松地向其发送无效请求 `/content/dam/site-a`。

事实上，您告诉调度程序使其失效的路径并不重要——只要它位于同一站点中，位于同一“子树”中。 您甚至不必使用真正的资源路径。 它也可以是“虚拟”的：

`GET /dispatcher-invalidate
Invalidate-path /content/mysite/dummy`

![](assets/chapter-1/resource-path.png)

1. 当DAM中的文件发生更改时，将触发发布系统上的监听器

2. 监听器向调度程序发送失效请求。 由于自动失效，我们在自动失效中发送的路径并不重要，除非它位于站点的主页下——或更精确地位于站点静态文件级别。

3. 状态文件已更新。

4. 下次请求主页时，主页将重新呈现。 新的指纹／日期从图像的lastModified属性中取得，作为附加选择器

5. 这会隐式创建对新图像的引用

6. 如果实际请求了映像，则会在调度程序中创建并存储新的再现


#### 清理的必要性

喔。 已完成. 好！

还不是。

路径，

`/content/mysite/home/jcr:content/par/respi.img.fp-2018-31-12-23-59.jpg`

与任何失效的资源无关。 记住? 我们只使“虚拟”资源失效，并依赖自动失效来考虑“主”无效。 图像本身可能永远不会被 _实际删_ 除。 因此，缓存会增长并增长。 当图像被更改和激活时，它们会在Dispatcher的文件系统中获得新文件名。

以下三个问题是无法物理删除缓存文件并无限期保留它们：

1. 你在浪费存储能力——这很明显。 当然——过去几年，存储变得更便宜。 但过去几年，图像分辨率和文件大小也在增加——视网膜样的显示器已经出现，它们渴望获得水晶般锐利的图像。

2. 尽管硬盘已变得更便宜，但“存储”可能也不会变得更便宜。 我们看到一种趋势，即没有（廉价）裸机硬盘存储，而是由您的数据中心提供商在NAS上租用虚拟存储。 这种存储更可靠、更灵活，但也更昂贵。 你可能不想通过存储过时的垃圾来浪费它。 这不仅与主存储有关，还考虑备份。 如果您有现成的备份解决方案，则可能无法排除缓存目录。 最后，您还备份垃圾数据。

3. 更糟的是：您可能仅在有限时间内购买了某些图像的使用许可证——只要您需要它们。 现在，如果许可证过期后仍存储图像，这可能被视为版权侵权。 您可能不再在网页中使用图像，但Google仍会找到它们。

最后，您会找到一些家政任务，来清理所有比……更旧的文件……让我们假设一周时间，来控制这种乱七八糟的行为。

#### 滥用URL指纹进行拒绝服务攻击

但等等，这个解决方案还有一个缺陷：

我们滥用选择器作为参数：fp-2018-31-12-23-59作为某种“高速缓存杀手”动态生成。 但也许有些无聊的孩子（或者一个搜索引擎爬虫，它已经疯了）开始会请求这些网页：

```
/content/mysite/home/jcr:content/par/img.fp-0000-00-00-00-00.jpg
/content/mysite/home/jcr:content/par/img.fp-0000-00-00-00-01.jpg
/content/mysite/home/jcr:content/par/img.fp-0000-00-00-00-02.jpg

…
```

每个请求都将绕过调度程序，导致Publish实例加载。 而且，甚至更糟的是，在调度程序上创建一个相应的文件。

因此……您不仅需要使用指纹作为简单的缓存杀手，还需要检查图像的jcr:lastModified日期，如果它不是预期日期，则返回404。 在发布系统上，这需要一些时间和CPU周期……这是您最初希望阻止的。

#### 高频发布中URL指纹的注意事项

您不仅可以对来自DAM的资产使用指纹模式，还可以对JS和CSS文件及相关资源使用。

[版本化Clientlibs](https://adobe-consulting-services.github.io/acs-aem-commons/features/versioned-clientlibs/index.html) 是使用此方法的模块。

但在这里，您可能会面临另一个警告： URL指纹：它将URL与内容绑定。 不更改URL（aka.，更新修改日期），就不能更改内容。 这就是指纹的设计初衷。 但请考虑，您即将推出一个新版本，其中包含新的CSS和JS文件，从而包含新指纹的新URL。 所有HTML页面仍引用旧的指纹URL。 因此，要使新版本能够一致工作，您需要一次使所有HTML页面失效，以强制重新渲染并引用新指纹文件。 如果您有多个站点依赖相同的库，这可能需要大量重新渲染——而此时您无法利用该库 `statfiles`。 因此，请准备好在转出后查看发布系统上的负载峰值。 您可能会考虑在Dispatcher前进行蓝绿色部署，并加热缓存，或者考虑基于TTL的缓存……无限的可能性。

#### 短暂的休息

这是很多细节要考虑，对吧？ 它拒绝被理解、测试和调试。 所有这一切都是为了一个看似优雅的解决方案。 诚然，它很优雅——但只从AEM的角度来看。 和调度程序一起，它变得恶心。

但是，它并不能解决一个基本警告，如果图像在不同页面上被多次使用，它们将缓存在这些页面下。 这里没有多少缓存协同效应。

通常，URL指纹识别是工具包中的一个好工具，但您需要谨慎应用，因为它可能在解决少数现有问题的同时造成新问题。

那，那是一个很长的篇章。 但我们经常看到这种模式，我们觉得有必要把所有利与弊的情况全貌呈现给你。 URL指纹可以解决后台处理程序模式中的一些固有问题，但实施的工作量很大，您还需要考虑其他更简单的解决方案。 我们的建议是，始终检查您的URL是否可以基于提供的资源路径，而不是中间组件。 下一章我们将讲到这个。

##### 运行时依赖关系解析

运行时依赖关系解决是我们在一个项目中考虑的概念。 但是想完它就变得相当复杂，我们决定不实施它。

下面是基本的想法：

调度程序不知道资源的相关性。 它只是一堆没有任何语义的单个文件。

AEM对依赖关系也知之甚少。 它缺少正确的语义或“依赖性跟踪器”。

AEM了解一些参考。 在您尝试删除或移动引用的页面或资产时，系统会使用此知识向您发出警告。 在删除资产时，通过查询内部搜索来执行此操作。 内容引用确实有一种非常特殊的表单。 它们是以“/content”开头的路径表达式。 因此，可以轻松地对它们进行全文索引，并在必要时进行查询。

在我们的情况下，我们需要在发布系统上使用一个自定义复制代理，该代理在该路径发生更改时触发对特定路径的搜索。

假设

`/content/dam/flower.jpg`

发布时已更改。 工程师将启动“/content/dam/flower.jpg”搜索并查找引用这些图像的所有页面。

然后，它可以向调度程序发出许多无效请求。 每个包含资产的页面对应一个。

理论上，这应该行得通。 但仅针对一级相关性。 您不希望将该方案应用于多级相关性，例如，在页面上使用的体验片段上使用图像时。 事实上，我们认为这种方法过于复杂——并且可能存在运行时问题。 通常最好的建议是不要在事件处理程序中进行昂贵的计算。 特别是搜索会变得非常昂贵。

##### 结论

我们希望我们已经充分讨论了勺子模式，以帮助您确定何时使用，而不是在您的实施中使用。

## 避免调度程序问题

### 基于资源的URL

解决依赖问题的一个更优雅的方法是完全没有依赖。 避免在使用一个资源简单地代理另一个资源时发生的人工依赖关系，如上一个示例中所示。 尽量将资源视为“孤立”实体。

我们的例子很容易解决：

![使用绑定到图像而不是组件的servlet假脱机图像。](assets/chapter-1/spooling-image.png)

*使用绑定到图像而不是组件的servlet假脱机图像。*

<br> 

我们使用资产原始资源路径来呈现数据。 如果需要按原样渲染原始图像，我们只需为资产使用AEM.默认渲染器。

如果需要对特定组件执行一些特殊处理，我们会在该路径上注册一个专用servlet并选择器，以代表该组件进行转换。 我们以&quot;。respi&quot;为榜样。 选择器。 最好跟踪全局URL空间（如）上使用的选择器名称，并 `/content/dam`有良好的命名约定以避免命名冲突。

顺便说一下，我们看不到任何代码一致性问题。 Servlet可以在与组件sling模型相同的Java包中定义。

我们甚至可以在全局空间中使用其他选择器，例如，

`/content/dam/flower.respi.thumbnail.jpg`

轻松，对吧？ 那为什么人们会想出复杂的图案，比如勺子？

那么，我们可以解决避免内部内容引用的问题，因为外部组件在内部资源的呈现中增加了很少的价值或信息，它很容易被编码成一组静态选择器，这些选择器控制单个资源的表示。

但是，有一类案例无法通过基于资源的URL轻松解决。 我们将这种类型的案例称为“参数注入组件”，并在下一章中加以讨论。

### 参数注入组件

#### 概述

最后一章中的后台处理程序只是资源的一个薄包装。 它给解决问题带来了更多麻烦。

我们可以使用一个简单的选择器来轻松替换该包装，并添加一个按照servlet来满足此类请求。

但如果“respi”组件不仅仅是一个代理怎么办。 如果组件真正有助于组件的呈现，该怎么办？

让我们介绍一个“respi”组件的小扩展，这有点改变游戏规则。 我们将再次引入一些天真的解决方案，以应对新挑战并说明新挑战的不足之处。

#### Respi2组件

响应2组件是显示响应式图像的组件，响应组件也是如此。 但是它有个附加的，

![CRX结构：respi2组件向投放添加quality属性](assets/chapter-1/respi2.png)

*CRX结构：respi2组件向投放添加quality属性*

<br> 

图像是jpegs，可以压缩jpegs。 压缩jpeg图像时，以质量换文件大小。 压缩定义为介于“1”到“100”之间的数字“quality”参数。 “1”表示“小但质量差”,“100”表示“质量好但文件大”。 那么，哪个是完美价值？

与所有IT事务一样，答案是：“这要看情况。”

这取决于主题。 具有高对比度边缘的基元，如书写文本、建筑照片、插图、草图或产品包装盒照片（上面有清晰的轮廓和文字），通常属于该类别。 具有较柔和的颜色和对比度过渡（如风景或肖像）的图案可以更加压缩，而不会出现明显的质量损失。 大自然的照片通常会落入类别。

此外，根据图像的使用位置，您可能希望使用其他参数。 Teaser中的小缩略图可能比在屏幕范围的英雄横幅中使用的同一图像承受更好的压缩。 这意味着质量参数不是图像固有的，而是图像和上下文固有的。 还有作者的品味。

简而言之：没有适合所有图片的完美设置。 没有一刀切。 作者最好决定。 他将调整“quality”参数作为组件中的属性，直到他对质量感到满意，并且不会进一步牺牲带宽。

我们现在在DAM中有一个二进制文件和一个提供质量属性的组件。 URL应该是什么样子？ 哪个组件负责假脱机？

#### 天真的方法1:将属性作为查询参数传递

>[!WARNING]
>
>这是反模式。 不要使用它。

在最后一章中，组件呈现的图像URL如下所示：

`/content/dam/flower.respi.jpg`

所缺少的只是质量值。 该组件知道作者输入了哪些属性……在渲染标记时，它可以作为查询参数轻松传递给图像渲染servlet，如 `flower.respi2.jpg?quality=60`:

```plain
  <div class="respi2">
  <picture>
    <source src="/content/dam/flower.respi2.jpg?quality=60" …/>
    …
  </picture>
  </div>
  …
```

这是个坏主意。 记住? 具有查询参数的请求不可缓存。

#### 天真的方法2:将其他信息作为选择器传递

>[!WARNING]
>
>这可能会成为一种反模式。 小心使用。

![将组件属性作为选择器传递](assets/chapter-1/passing-component-properties.png)

*将组件属性作为选择器传递*

<br> 

这是最后一个URL的轻微变化。 只是这一次，我们使用一个选择器将属性传递给servlet，以便结果可缓存：

`/content/dam/flower.respi.q-60.jpg`

这样更好，但还记得上一章中那个讨厌的“脚本小孩”，谁在寻找这种模式？ 他会看到，在价值上反复重复，他能走多远：

```plain
  /content/dam/flower.respi.q-60.jpg
  /content/dam/flower.respi.q-61.jpg
  /content/dam/flower.respi.q-62.jpg
  /content/dam/flower.respi.q-63.jpg
  …
```

这同样会绕过缓存并在发布系统上创建负载。 所以，这可能是个坏主意。 只筛选一小部分参数即可缓解此问题。 你只想允许 `q-20, q-40, q-60, q-80, q-100`。

#### 使用选择器时筛选无效请求

减少选择器数量是一个不错的开始。 作为经验法则，您应始终将有效参数的数量限制为绝对最小值。 如果您这样做，您甚至可以利用AEM外的Web 应用程序防火墙，使用一组静态过滤器，而无需深入了解基础AEM系统，从而保护您的系统：

`Allow: /content/dam/(-\_/a-z0-9)+/(-\_a-z0-9)+
\.respi\.q-(20|40|60|80|100)\.jpg`

如果您没有Web 应用程序防火墙，则必须在调度程序或AEM中进行过滤。 如果是在AEM中执行，请确保

1. 该滤波器实现效率高，不占用CRX太多，不浪费内存和时间。

2. 过滤器会响应“404 —— 未找到”错误消息

我们再强调一下最后一点。 HTTP对话的外观如下：

```plain
  GET /content/dam/flower.respi.q-41.jpg

  Response: 404 – Not found
  << empty response body >>
```

我们还看到了一些实现，它确实过滤了无效参数，但在使用无效参数时返回了有效的回退呈现。 假设，我们只允许20-100个参数。 中间的值将映射到有效值。 所以，

`q-41, q-42, q-43, …`

会始终响应与q-40相同的图像：

```plain
  GET /content/dam/flower.respi.q-41.jpg

  Response: 200 – OK
  << flower.jpg with quality = 40 >>
```

这种方法毫无帮助。 这些请求实际上是有效请求。  它们消耗处理能力并占用调度程序缓存目录中的空间。

最好还是返回 `301 – Moved permanently`:

```plain
  GET /content/dam/flower.respi.q-41.jpg

  Response: 301 – Moved permanently
  Location: /content/dam/flower.respi.q-40.jpg
```

这里AEM告诉浏览器。 “我没有 `q-41`。 但是，你可以问我关于 `q-40` &quot;

这为会话增加了一个额外的请求——响应循环，这有点开销，但比完全处理要便宜 `q-41`。 您还可以利用已缓存的文件 `q-40`。 但是，您必须了解，302个响应未在调度程序中缓存，我们讨论的是在AEM中执行的逻辑。 一遍又一遍。 因此，您最好让它纤细、快速。

我们个人最喜欢404响应。 这让事情变得非常明显。 在分析日志文件时，还有助于检测网站上的错误。 可以预定301，其中应始终分析并消除404。

## 安全性——偏移

### 筛选请求

#### 最佳筛选位置

最后，我们指出了过滤已知选择器传入流量的必要性。 这就留下了一个问题：我实际应该在哪里筛选请求？

那要看情况。 越快越好。

#### Web 应用程序防火墙

如果您有专为Web安全而设计的Web 应用程序防火墙设备或“WAF”，您绝对应利用这些功能。 但您可能会发现，WAF是由对内容应用程序知识有限的人员运行的，他们会过滤有效请求或让过多有害请求。 也许您会发现，运营WAF的人员分配给了不同部门，他们的班次和发布计划各不相同，沟通可能不像直接队友那样紧密，而且您并不总是能及时得到变化，这意味着最终您的开发和内容速度会受到影响。

你最终可能会有一些一般规则，甚至阻止列表是，你的直觉告诉它，可能会收紧。

#### 调度程序和发布过滤

下一步是在Apache核心和／或调度程序中添加URL过滤规则。

您只能访问URL。 您只能使用基于模式的过滤器。 如果您需要设置更多基于内容的过滤（如只允许文件使用正确的时间戳），或者您希望对作者进行一些过滤——您最终将编写类似于自定义servlet过滤器的内容。

#### 监视和调试

实际上，您在每个级别都会拥有一些安全性。 但是，请确保您有办法了解请求的筛选级别。 确保您可以直接访问发布系统、调度程序和WAF上的日志文件，以找出链中的哪个过滤器正在阻止请求。

### 选择器和选择器扩散

最后一章采用“选择器参数”的方法快速、简便，可以加快新组件的开发速度，但有局限性。

设置“quality”属性只是一个简单的示例。 但是，Servlet还希望“width”的参数具有更多功能。

您可以通过减少可能的选择器值来减少有效URL的数量。 您也可以使用宽度执行相同的操作：

质量= q-20、q-40、q-60、q-80、q-100

宽度= w-100、w-200、w-400、w-800、w-1000、w-1200

但所有组合现在都是有效的URL:

```
/content/dam/flower.respi.q-40.w-200.jpg
/content/dam/flower.respi.q-60.w-400.jpg
…
```

现在，我们已为一个资源提供5x6=30个有效URL。 每个附加属性都会增加复杂性。 也许有些属性，这些属性不能减到合理的值。

所以，这种方法也有局限性。

#### 无意暴露API

这里发生了什么？ 如果仔细观察，我们会发现，我们正逐渐从静态呈现转变为高度动态的网站。 我们无意中为客户的浏览器显示了一个图像渲染API，该API实际上仅供作者使用。

编辑页面的作者应完成图像的质量和大小设置。 Servlet暴露的相同功能可被视为拒绝服务攻击的功能或矢量。 它实际上是什么，取决于背景。 网站对业务有多重要？ 服务器上的负载是多少？ 还剩多少头部空间？ 您有多少预算用于实施？ 你必须平衡这些因素。 您应该了解利弊。

## 后卫模式——再论与修复

### 假脱机程序如何避免暴露API

我们在最后一章中对欺骗者的模式失去了信誉。 是时候恢复它了。

![](assets/chapter-1/spooler-pattern.png)

后台处理器模式可防止我们在上一章讨论的API暴露问题。 属性会存储并封装在组件中。 访问这些属性所需的只是组件的路径。 我们不必将URL用作工具，在标记和二进制渲染之间传输参数：

1. 当在主请求循环中请求组件时，客户端将呈现HTML标记

2. 组件路径用作从标记到组件的回参考

3. 浏览器使用此反向引用请求二进制文件

4. 当请求命中组件时，我们手中拥有所有属性来调整二进制数据的大小、压缩二进制数据并设置其假脱机

5. 图像通过组件传输到客户端浏览器

后卫模式毕竟没那么糟糕，所以才如此受欢迎。 如果只在缓存失效方面不那么麻烦……

### 倒排后音乐器——两全其美？

这就引出了问题。 为什么我们不能同时得到两个世界的最佳结果？ 后台处理程序模式的良好封装以及基于资源的URL的良好缓存属性？

我们必须承认，我们在一个真实的现场项目中还没有看到这一点。 不过，让我们大胆尝试一下这里的想法——作为你自己解决方案的起点。

我们称这种模式为 _倒置假脱机_.. 反转假脱机程序必须基于图像资源，才能具有所有好的缓存失效属性。

但它不能公开任何参数。 所有属性都应封装在组件中。 但我们可以公开组件路径——作为对属性的不透明引用。

这会导致表单中的URL:

`/content/dam/flower.respi3.content-mysite-home-jcrcontent-par-respi.jpg`

`/content/dam/flower` 是图像资源的路径

`.respi3` 是选择正确的servlet以传送图像的选择器

`.content-mysite-home-jcrcontent-par-respi` 是其他选择器。 它将编码到组件的路径，该组件存储图像转换所需的属性。 选择器仅限于比路径更小的字符范围。 这里的编码方案只是一个示范。 它用“-”替换“/”。 路径本身也可以包含“-”，这并不考虑。 在实际例子中，建议使用更复杂的编码方案。 Base64应该可以。 但它会让调试变得更加困难。

`.jpg` 是文件后缀

### 结论

对勺子的讨论比预期的更长、更复杂。 我们欠你个借口。 但我们觉得有必要向您展示很多方面——好的和坏的方面——以便您能够对哪些在调度程序领域有效以及哪些不有效产生一些直觉。

## Statfile和Statfile级别

### 基本信息

#### 简介

我们之前已经简略地提 _到过_ statfile。 它与自动失效相关：

如果调度程序文件系统中所有配置为自动失效的缓存文件的上次修改日期早于上次修改日期，则这些缓存文件 `statfile's` 将被视为无效。

>[!NOTE]
>
>我们讨论的上次修改日期是缓存文件，即从客户端浏览器请求文件并最终在文件系统中创建文件的日期。 它不是资 `jcr:lastModified` 源的日期。

statfile()的上次修改日`.stat`期是调度程序收到AEM的失效请求的日期。

如果您有多个调度程序，这可能会产生奇怪的效果。 您的浏览器可以有一个更新版本的调度程序（如果您有多个调度程序）。 或者，调度程序可能认为其他调度程序发布的浏览器版本已过期，会不必要地发送新副本。 这些效果对性能或功能要求没有显着影响。 随着时间的推移，当浏览器具有最新版本时，它们会逐渐平衡。 但是，在优化和调试浏览器缓存行为时，这可能会有些混乱。 所以要警告。

#### 使用/statfilelevel设置失效域

当我们引入自动失效和statfile时，我们说，当有任何 *更改* ，并且所有文件仍然相互依赖时，所有文件都被视为无效。

那不太准确。 通常，共享一个通用主导航根目录的所有文件都是相互依赖的。 但一个AEM实例可以托管多个网站——独 *立网* 站。 不共享通用导航——事实上，不共享任何内容。

因为A站点有变，使B站点失效岂不是浪费？ 是的。 而且不一定是那样。

调度程序提供了将站点彼此分离的简单方法：那个 `statfiles-level`。

它是一个数字，它定义了上文件系统中的哪个级别，两个子树被视为“独立”。

让我们看看statfilelevel为0的默认情况。

![/statfilelevel &quot;0&quot;:_. _stat_ _在docroot中创建。 失效域横跨整个安装，包括所有站点](assets/chapter-1/statfile-level-0.png)

`/statfileslevel "0":` 文 `.stat` 件在Docroot中创建。 失效域横跨整个安装，包括所有站点。

无论哪个文件失效， `.stat` 都会始终更新调度程序Docroot顶部的文件。 因此，当您失 `/content/site-b/home`效时，中的所有文 `/content/site-a` 件也将失效，因为它们现在比Docroot中 `.stat` 的文件旧。 当你失效时，显然不是你需要的 `site-b`。

在此示例中，您宁愿将 `statfileslevel` 设置 `1`为。

现在，如果您发布，并因此使 `/content/site-b/home` 文件或以下任何其 `/content/site-b`他资源 `.stat` 失效，则在创建文件 `/content/site-b/`。

以下内 `/content/site-a/` 容不受影响。 此内容将与位于的文 `.stat` 件进行比 `/content/site-a/`较。 我们创建了两个单独的失效域。

![statfilelevel &quot;1&quot;创建不同的失效域](assets/chapter-1/statfiles-level-1.png)

*statfilelevel &quot;1&quot;创建不同的失效域*

<br> 

大型设备通常结构更复杂、更深。 一个共同的方案是按品牌、国家和语言来构建网站。 在这种情况下，您可以设置更高的statfiles级别。 _1_ 将创建每个品牌的失效域 _、_ 每个国家／地 _区2个_ 、每种语言3个。

### 同质场地结构的必要性

statfilelevel同样应用于设置中的所有站点。 因此，必须让所有的场所都按照同一结构，同一开始。

考虑一下您的投资组合中有一些品牌只在少数小市场销售，而其他品牌则在全球销售。 小型市场碰巧只有一种本地语言，而在全球市场，有些国家使用的语言不止一种：

```plain
  /content/tiny-local-brand/finland/home
  /content/tiny-local-brand/finland/products
  /content/tiny-local-brand/finland/about
                              ^
                          /statfileslevel "2"
  …

  /content/tiny-local-brand/norway
  …

  /content/shiny-global-brand/canada/en
  /content/shiny-global-brand/canada/fr
  /content/shiny-global-brand/switzerland/fr
  /content/shiny-global-brand/switzerland/de
  /content/shiny-global-brand/switzerland/it
                                          ^
                                /statfileslevel "3"
  ..
```

前者要求2 `statfileslevel` 岁 _，后_&#x200B;者要 _3岁_。

不是理想情况。 如果将其设置为 _3_，则自动失效将在子分支之间的较小站点内无 `/home`效， `/products` 并且 `/about`。

将其设 _置为_ 2表示，在较大的站点中，您声明 `/canada/en` 并依赖 `/canada/fr` ，而它们可能不是。 因此，中的每个 `/en` 失效也将失效 `/fr`。 这将导致缓存命中率略有降低，但仍优于传送陈旧的缓存内容。

当然，最好的解决方案是让所有网站的根基都变得同样深厚：

```
/content/tiny-local-brand/finland/fi/home
/content/tiny-local-brand/finland/fi/products
/content/tiny-local-brand/finland/fi/about
…
/content/tiny-local-brand/norway/no/home
                                 ^
                        /statfileslevel "3"
```

### 站点间链接

现在哪个级别合适？ 这取决于您在站点之间的依赖关系数量。 您为渲染页面而解析的包含内容被视为“硬相关性”。 在本指南的开 _头_ 引入Teaser组 _件时，我_ 们演示了这种包含。

_超链接_ 是一种更柔和的依赖关系形式。 很可能，您将在一个网站中超链接……并且您的网站之间不太可能有链接。 简单超链接通常不会在网站之间创建依赖关系。 只需考虑您从您的网站设置到facebook的外部链接……如果facebook上有任何更改，您就不必呈现您的页面，反之，对吗？

从链接的资源（例如，导航标题）读取内容时，会发生依赖关系。 如果您只依赖本地输入的导航标题，而不是从目标页面中绘制这些属性（与使用外部链接时一样），则可以避免此类依赖关系。

#### 意外的依赖关系

但是，您的设置中可能会有一部分内容，这些网站（据称是独立的）汇聚在一起。 让我们看看我们在其中一个项目中遇到的现实场景。

客户的站点结构与上一章中描述的结构类似：

```
/content/brand/country/language
```

例如，

```
/content/shiny-brand/switzerland/fr
/content/shiny-brand/switzerland/de

/content/shiny-brand/france/fr

/content/shiny-brand/germany/de
```

每个国家都有自己的领域，

```
www.shiny-brand.ch

www.shiny-brand.fr

www.shiny-brand.de
```

语言站点之间没有可导航的链接，也没有明显的包含项，因此我们将statfilelevel设置为3。

所有站点基本提供相同的内容。 唯一的主要区别是语言。

像谷歌这样的搜索引擎考虑在不同URL上拥有相同的内容是“欺骗的”。 用户可能希望通过创建提供相同内容的场来尝试获得更高的排名或更频繁地列出。 搜索引擎可以识别这些尝试，并实际将页面排序得更低，只是重复利用内容。

通过在每个页面的标题部分中为每个相关页面设置标记，您可以防止排名下降，确保您实际拥有多个页面并且内容相同，并且您不尝试对系统进行“游戏”(请参阅 [“Tell Google about localized versions of your page](https://support.google.com/webmasters/answer/189077?hl=en)`<link rel="alternate">` ):

```
# URL: www.shiny-brand.fr/fr/home/produits.html

<head>

  <link rel="alternate" 
        hreflang="fr-ch" 
        href="http://www.shiny-brand.ch/fr/home/produits.html">
  <link rel="alternate" 
        hreflang="de-ch" 
        href="http://www.shiny-brand.ch/de/home/produkte.html">
  <link rel="alternate" 
        hreflang="de-de" 
        href="http://www.shiny-brand.de/de/home/produkte.html">

</head>

----

# URL www.shiny-brand.de/de/home/produkte.html

<head>

  <link rel="alternate" 
        hreflang="fr-fr" 
        href="http://www.shiny-brand.fr/fr/home/produits.html">
  <link rel="alternate" 
        hreflang="fr-ch" 
        href="http://www.shiny-brand.ch/fr/home/produits.html">
  <link rel="alternate" 
        hreflang="de-ch"
         href="http://www.shiny-brand.ch/de/home/produits.html">

</head>
```

![全部链接](assets/chapter-1/inter-linking-all.png)

*全部链接*

<br> 

一些SEO专家甚至辩称，这可能会将名声或“链接”从一种语言的高级网站转移到另一种语言的同一网站。

该方案不仅产生了许多链接，还产生了一些问题。 以n语言表示 _p所需的链_ 接 __ 数 _为p x(n<sup></sup>-n_):每个页面链接到彼此的页&#x200B;_面(n x n_)，但其本身&#x200B;_除外(-n_)。 此方案将应用于每页。 如果我们有一个4种语言的小站点，其页面数为20页，则每个站点的链接数 _为_ 240个。

首先，您不希望编辑者必须手动维护这些链接——这些链接必须由系统自动生成。

其次，它们应该准确。 当系统检测到新的“相对”时，您希望将其从所有其他页面链接到具有相同内容（但使用不同语言）。

在我们的项目中，新的相对页面经常出现。 但它们并不是作为“替代”环节出现。 例如，当页面 `de-de/produkte` 在德国网站上发布时，其他网站上不会立即显示该页面。

原因是，在我们的设置中，网站应该是独立的。 因此，德国网站上的更改没有在法国网站上触发无效。

您已经知道一个解决方案如何解决这个问题。 只需将statfilelevel减小到2即可扩展失效域。 当然，这也会降低缓存命中率，因此失效更频繁。

就我们而言，情况更加复杂：

尽管我们有相同的内容，但实际上并非品牌名称的国家／地区却有所不同。

`shiny-brand` 在法 `marque-brillant` 国和德国 `blitzmarke` 被称为：

```
/content/marque-brillant/france/fr
/content/shiny-brand/switzerland/fr
/content/shiny-brand/switzerland/de
/content/blitzmarke/germany/de
…
```

这本意是将这个级别设 `statfiles` 为1，这将导致失效域过大。

重组网站将能解决这个问题。 将所有品牌合并到一个共同的根中。 但那时我们没有能力，而且——那只会让我们达到2级。

我们决定坚持第3层，并支付不总是具有最新“替代”链接的价格。 为了减轻问题，我们在调度程序上运行了一个“报纸”cron作业，它将清除1周以前的文件。 最终，所有页面都在某个时间点重新呈现。 但这是一个取舍，需要在每个项目中单独决定。

## 结论

我们介绍了一些关于Dispatcher如何正常工作的基本原则，并给出了一些示例，在这些示例中，您可能需要付出更多的实施努力才能正确实现它，并且您可能希望取得平衡。

我们没有详细介绍如何在调度程序中配置它。 我们希望您首先了解基本概念和问题，而不要过早地失去控制台。 而且，实际的配置工作有详细的记录，如果您了解基本概念，您应该知道各种交换机的用途。

## 调度程序提示与技巧

在本书的第一部分，我们将随机收集一些提示和技巧，这些提示和技巧可能对某种情况有用。 正如我们之前所做的，我们不是在介绍解决方案，而是介绍这个想法，以便您有机会了解该想法和概念，并链接到更详细描述实际配置的文章。

### 正确的失效时间

如果您安装了AEM作者并立即发布，则拓扑会有些奇怪。 作者同时将内容发送到发布系统，并将失效请求发送到调度程序。 由于Publish系统和调度程序都通过队列与作者分离，因此时间可能有点不合适。 在发布系统上更新内容之前，调度程序可以收到作者的无效请求。

如果客户端同时请求该内容，调度程序将请求和存储过时的内容。

在发布系统收到内容后，一个更可靠的设 _置_ 将发送失效请求。 文章“从发[布实例中使调度程序缓存失效](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html#InvalidatingDispatcherCachefromaPublishingInstance)”介绍了详细信息。

**引用**

[helpx.adobe.com - Publishing Instance中的调度程序缓存无效](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html#InvalidatingDispatcherCachefromaPublishingInstance)

### HTTP头和头缓存

过去，调度程序只是在文件系统中存储普通文件。 如果您需要将HTTP头发送给客户，则需根据您从文件或位置获得的少量信息配置Apache。 在AEM中实施严重依赖HTTP头的Web应用程序时，这尤其令人讨厌。 在仅AEM的实例中，一切正常，但使用Dispatcher时不行。

通常，您开始使用由资源路径和后缀派生的信息，将缺 `mod_headers` 失的标头重新应用到Apache服务器中的资源。 但这并不总是足够。

尤其令人讨厌的是，即使Dispatcher有第一个未缓存 _的_ ，对浏览器的响应也来自具有完整范围标头的Publish系统，而后续响应由Dispatcher生成，其标头集有限。

从Dispatcher 4.1.11开始，Dispatcher可以存储由发布系统生成的头。

这样，您就不必在Dispatcher中复制头逻辑，并充分发挥HTTP和AEM的强大表现力。

**引用**

* [helpx.adobe.com —— 缓存响应头](https://helpx.adobe.com/experience-manager/kb/dispatcher-cache-response-headers.html)

### 单个缓存异常

您可能希望一般缓存所有页面和图像——但在某些情况下会出现异常。 例如，您希望缓存PNG图像，但不要缓存显示captcha的PNG图像（假定在每个请求中都会更改）。 调度程序可能无法将captcha识别为captcha...但AEM确实可以识别。 它可以通过发送相应的报头和响应，要求调度程序不要缓存该请求：

```plain
  response.setHeader("Dispatcher", "no-cache");

  response.setHeader("Cache-Control: no-cache");

  response.setHeader("Cache-Control: private");

  response.setHeader("Pragma: no-cache");
```

缓存控制和编译指示是正式的HTTP头，它们会传播到高级缓存层（如CDN）并由其解释。 标 `Dispatcher` 头只是调度程序不缓存的提示。 它可以用于通知调度程序不要缓存，同时仍允许上缓存层进行缓存。 事实上，很难找到这样的案例。 但是我们确定有些，某处。

**引用**

* [调度程序——无缓存](https://helpx.adobe.com/experience-manager/kb/DispatcherNoCache.html)

### 浏览器缓存

最快的http响应是浏览器本身给出的响应。 在高负载下，请求和响应不必通过网络传送到Web服务器。

您可以通过设置资源的过期日期来帮助浏览器决定何时要求服务器提供文件的新版本。

通常，您通过使用Apache的或存储来自 `mod_expires` AEM的Cache-Control和Expires Header（如果需要更多单独的控件）来静态地执行此操作。

浏览器中缓存的文档可以具有三个最新级别。

1. _保证新鲜_ -浏览器可以使用缓存的文档。

2. _可能过时_ -浏览器应首先询问服务器缓存的文档是否仍为最新，

3. _过时_ -浏览器必须要求服务器提供新版本。

第一个由服务器设置的过期日期保证。 如果资源未过期，则无需再次询问服务器。

如果文档到达过期日期，仍可以是新的。 到期日期在文档送达时设置。 但是，您通常不会提前知道新内容何时可用，因此这只是保守的估计。

要确定浏览器缓存中的文档是否仍与新请求时发送的文档相同，浏览器可以使 `Last-Modified` 用的日期。 浏览器会询问服务器：

“_我有6月10日的版本……我需要更新吗？_”而服务器可以

“_304 —— 您的版本仍为最新_”，无需重新传输资源，或者服务器可以

HTTP _头中的“200 —— 此处为较新版本_”,HTTP正文中的实际较新内容。

要使第二部分正常工作，请确保将日 `Last-Modified` 期传输到浏览器，以便其具有要求更新的参考点。

我们之前已解释，当调度程 `Last-Modified` 序生成日期时，该日期可能因不同请求而异，因为缓存的文件（及其日期）是在浏览器请求文件时生成的。 另一种方法是使用“e-tags”，即标识实际内容（例如，通过生成哈希代码）而不是日期的数字。

ACS[Commons](https://adobe-consulting-services.github.io/acs-aem-commons/features/etag/index.html)Package的“ _Etag Support_ ”使用此方法。 但这是有代价的：由于E-Tag必须作为头发送，但散列代码的计算需要完全读取响应，因此响应必须在主内存中完全缓冲，才能传送。 当您的网站更有可能拥有未缓存的资源，并且当然您需要留意AEM系统占用的内存时，这可能会对延迟产生负面影响。

如果您使用URL指纹，则可以设置很长的过期日期。 您可以在浏览器中永久缓存指纹资源。 新版本带有新URL标记，旧版本无需更新。

我们在引入假脱机模式时使用了URL指纹。 来自(CSS、JS) `/etc/design` 的静态文件很少更改，这也使它们成为可用作指纹的最佳候选文件。

对于常规文件，我们通常会设置一个固定方案，如每30分钟重新检查一次HTML、每4小时重新检查一次图像等。

浏览器缓存在创作系统中非常有用。 您希望尽可能多地缓存在浏览器中以增强编辑体验。 很遗憾，最昂贵的资源、无法缓存html页面……它们应在作者处频繁更改。

可以缓存包含AEM UI的花岗岩库相当长的时间。 您还可以在浏览器中缓存站点静态文件（字体、CSS和JavaScript）。 即使中的 `/content/dam` 图像也通常可以缓存约15分钟，因为它们的更改频率不像页面上的复制文本那样频繁。 在AEM中不以交互方式编辑图像。 在将它们上传到AEM之前，先对其进行编辑和批准。 因此，您可以假设它们没有文本更改的频率。

缓存UI文件、站点库文件和图像可以在您处于编辑模式时大幅加快页面重新加载。



**引用**

*[developer.mozilla.org —— 缓存](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)

* [apache.org —— 修改过期](https://httpd.apache.org/docs/current/mod/mod_expires.html)

* [ACS Commons - Etag支持](https://adobe-consulting-services.github.io/acs-aem-commons/features/etag/index.html)

### 正在截断URL

资源存储在

`/content/brand/country/language/…`

当然，这不是您想向客户展示的URL。 出于美感、可读性和SEO原因，您可能希望截断域名中已表示的部件。

如果您有域

`www.shiny-brand.fi`

通常不需要将品牌和国家纳入其中。 而不是，

`www.shiny-brand.fi/content/shiny-brand/finland/fi/home.html`

你会想的，

`www.shiny-brand.fi/home.html`

您必须在AEM上实现该映射——因为AEM需要知道如何根据截断的格式呈现链接。

但不要只依赖AEM。 如果这样做，则缓存的根目 `/home.html` 录中会有类似的路径。 现在，这是Finish、德语或加拿大网站的“家”吗？ 如果调度程序中 `/home.html` 有文件，调度程序如何知道当出现对的无效请求时，必须使 `/content/brand/fi/fi/home` 其失效。

我们看到一个项目，它为每个域分别提供不同的协作。 调试和维护是个噩梦——实际上，我们从未看到它运行得完美无瑕。

通过重构缓存，可以解决这些问题。 对于所有域，我们只有一个Docroot，失效请求可以处理1:1，因为服务器上的所有文件都是从开始的 `/content`。

截断部分也很容易。  AEM根据中的配置生成截断链接 `/etc/map`。

现在，当请求 `/home.html` 到达Dispatcher时，发生的第一件事就是应用一个在内部扩展路径的重写规则。

该规则是在每个主机配置中静态设置的。 简言之，规则是这样的，

```plain
  # vhost www.shiny-brand.fi

  RewriteRule "^(.\*\.html)" "/content/shiny-brand/finland/fi/$1"
```

在文件系统中，我们现 `/content`在有基于简单的路径，这也可以在“作者”和“发布”中找到——这有助于调试很多。 更不用说正确的失效了——这已不再是一个问题。

注意，我们仅对“可见”URL和在浏览器的URL插槽中显示的URL执行了此操作。 例如，图像的URL仍是纯“/content”URL。 我们认为，在搜索引擎优化方面，美化“主”URL就足够了。

有一个共同的多克罗也有另一个好的特征。 当调度程序中出现任何问题时，我们可以通过执行来清理整个缓存，

`rm -rf /cache/dispatcher/*`

（在高负荷峰值时，您可能不想做的事情）。

**引用**

* [apache.org —— 修改重写](https://httpd.apache.org/docs/2.4/mod/mod_rewrite.html)

* [helpx.adobe.com —— 资源映射](https://helpx.adobe.com/experience-manager/6-4/sites/deploying/using/resource-mapping.html)

### 错误处理

在AEM类中，您将学习如何在Sling中项目错误处理程序。 这与编写常用模板没有太大区别。 您只需在JSP或HTL中编写模板，对吗？

是的，但这只是AEM部分。 记住——调度程序不缓存 `404 – not found` 或响 `500 – internal server error` 应。

如果您在每个（失败）请求上动态呈现这些页面，则发布系统上将有不必要的高负载。

我们发现，有用的是，在出错时不渲染完整错误页面，而只渲染该页面的超简小版本，甚至是静态版本，没有任何装饰或逻辑。

这当然不是客户看到的。 在Dispatcher中，我们注 `ErrorDocuments` 册了：

```
ErrorDocument 404 "/content/shiny-brand/fi/fi/edocs/error-404.html"
ErrorDocument 500 "/content/shiny-brand/fi/fi/edocs/error-500.html"
```

现在，AEM系统只需通知调度程序出错，调度程序可以提供亮丽的错误文档版本。

这里应该注意两点。

首先， `error-404.html` 页面始终相同。 因此，没有“您搜索“产品”_的消_&#x200B;息会产生结果”。 我们很容易接受。

其次……如果我们看到内部服务器错误，或者更严重的是，我们遇到AEM系统的中断，就无法要求AEM显示错误页面，对吗？ 指令中定义的必要后续请 `ErrorDocument` 求也会失败。 我们通过运行cron-job来解决该问题，该cron-job会定期通过从其定义的位置提取错误页面，并将它们存 `wget` 储到指令中定义的静态文件 `ErrorDocuments` 位置。

**引用**

* [apache.org —— 自定义错误文档](https://httpd.apache.org/docs/2.4/custom-error.html)

### 缓存受保护的内容

默认情况下，调度程序在传送资源时不会检查权限。 它是有目的地实施的，以加快您的公共网站。 如果要通过登录保护某些资源，您基本有三个选项，

1. Protect请求前的资源到达缓存——即，通过调度程序前的SSO（单点登录）网关，或作为Apache服务器中的模块

2. 从缓存中排除敏感资源，从而始终从发布系统中实时提供这些资源。

3. 在调度程序中使用权限敏感型缓存

当然，您可以将三种方法结合使用。

**选项1**。 “SSO”网关仍可能由您的组织实施。 如果您的访问方案非常粗糙，您可能不需要AEM提供的信息来决定是授予还是拒绝对某个资源的访问。

>[!NOTE]
>
>此模式需要一 _个网关_ ，它 _拦截每个请_ 求并执行实际授 _权_ -向调度程序授予或拒绝请求。 如果您的SSO系统是验 _证器_，则该验证器仅建立必须实施选项3的用户的身份。 如果您在SSO系统手册中阅读了“SAML”或“OAauth”等术语，这是您必须实施选项3的强烈指标。


**选项2**。 “不缓存”通常是个坏主意。 如果采用这种方式，请确保被排除的流量和敏感资源数量较小。 或者，确保在发布系统中安装了一些内存中的缓存，发布系统可以处理由此产生的负载——更多情况在此系列的第三部分中。

**选项3**。 “对权限敏感的缓存”是一种有趣的方法。 调度程序正在缓存资源，但在传送资源之前，它会询问AEM系统是否可以缓存资源。 这会从调度程序向发布创建额外请求——但是，如果页面已缓存，通常会禁止发布系统重新呈现该页面。 但是，此方法需要一些自定义实现。 在文章权限敏感型缓存中 [在此处查找详细信息](https://helpx.adobe.com/experience-manager/dispatcher/using/permissions-cache.html)。

**引用**

* [helpx.adobe.com —— 权限敏感型缓存](https://helpx.adobe.com/experience-manager/dispatcher/using/permissions-cache.html)

### 设置宽限期

如果您经常在短时间内连续失效(例如，由于树激活或仅仅出于保持内容最新的需要而失效)，则可能会不断刷新缓存，而且访客几乎总是点击空缓存。

下图说明了访问单个页面时的可能时间。  当请求的不同页面数量增加时，问题当然会变得更严重。

![导致高速缓存无效的频繁激活在大多数时间内](assets/chapter-1/frequent-activations.png)

*导致高速缓存无效的频繁激活在大多数时间内*

<br> 

要缓解这种“缓存失效风暴”（有时称为“缓存失效风暴”）的问题，您可以不那么严格地解 `statfile` 释。

可以将调度程序设置为使 `grace period` 用自动失效。 这将在内部为修改日期添加一些 `statfiles` 额外时间。

假设您的修改 `statfile` 时间为今天12:00 ，并且 `gracePeriod` 设置为2分钟。 然后，所有自动失效的文件将在12:01和12:02被视为有效。 12点02分之后，它们将重新呈现。

参考配置建议 `gracePeriod` 两分钟，理由充分。 你会想，“两分钟？ 这几乎没什么。 我可以轻松等待10分钟，让内容出现……”。  因此，您可能会想设置一个更长的时间段，比如10分钟，假设您的内容至少在这10分钟之后出现。

>[!WARNING]
>
>这不是工作 `gracePeriod` 方式。 宽限期不 _是保证文档_ 在其后失效的时间，而是不发生失效的时间帧。 此帧内的每个后续失效都 _会延长_ 时间帧——这可以无限期地延长。

让我们来说明一 `gracePeriod` 个示例的实际使用方式：

假设您正在运行媒体站点，且编辑人员每5分钟提供一次定期内容更新。 考虑将宽限期设置为5分钟。

我们在12:00开始一个简单的示例。

12:00 —— 状态文件设置为12:00。 在12:05之前，所有缓存文件均被视为有效。

12:01 —— 出现失效。 将炉排时间延长到12:06

12:05 —— 另一位编辑发布了他的文章——将宽限期再延长到12:10。

等等……内容永远不会失效。 宽限期 *内的每* 个失效都有效地延长宽限期。 这 `gracePeriod` 个设计是为了抵御失效风暴……但你最终必须下雨……所以，保持相当短的时间 `gracePeriod` ，以防永远躲在避难所里。

#### 确定宽限期

我们想再介绍一下如何抵御失效风暴。 这只是个想法。 我们尚未在生产中尝试过，但我们发现这个概念足够有趣，可以与您分享这个想法。

如果 `gracePeriod` 常规复制时间间隔比您的时间间隔短，则该时间可能变得无法预测 `gracePeriod`。

另一个想法是：仅在固定时间间隔内失效。 介于两者之间的时间意味着提供陈旧的内容。 最终会发生失效，但会将许多失效收集到一个“批量”失效中，这样调度程序就有机会同时提供一些缓存内容，并给发布系统一些空气供呼吸。

实施过程如下：

您使用“自定义失效脚本”（请参阅引用），该脚本将在失效发生后运行。 此脚本将读取上 `statfile's` 次修改日期，并将其舍入到下一个时间间隔停止。 Unix shell命 `touch --time`令，让我们指定时间。

例如，如果将宽限期设置为30秒，调度程序会将statfile的上次修改日期舍入为30秒。 在两次之间发生的失效请求只需设置相同的下一个完整30秒。

![将失效延迟到下一个30秒全速将提高命中率。](assets/chapter-1/postponing-the-invalidation.png)

*将失效延迟到下一个30秒全速将提高命中率。*

<br> 

在失效请求和下一轮30秒的时隙之间发生的缓存命中被视为过时；发布有更新——但调度程序仍提供旧内容。

这种方法有助于定义较长的宽限期，而不必担心后续请求会无限期延长宽限期。 尽管如前所述，这只是一个想法，我们没有机会测试它。

**引用**

[helpx.adobe.com —— 调度程序配置](https://helpx.adobe.com/cn/experience-manager/dispatcher/using/dispatcher-configuration.html)

### 自动重取

您的站点具有非常特殊的访问模式。 传入的流量很大，而且大多数流量都集中在您页面的一小部分。 主页、活动登陆页和功能最丰富的产品详细信息页面会收到90%的流量。 或者，如果您运行新网站，则与旧网站相比，最近的文章具有更高的流量。

现在，这些页面很可能会在调度程序中进行缓存，因为请求的频率很高。

向调度程序发送任意失效请求，导致所有页面（包括您最受欢迎的一次页面）都失效。

随后，由于这些页面非常流行，因此会有来自不同浏览器的新传入请求。 以主页为例，

与现在一样，缓存无效，同时传入主页的所有请求都将转发到生成高负载的发布系统。

![在空缓存中并行请求到同一资源：请求将转发到发布](assets/chapter-1/parallel-requests.png)

*在空缓存中并行请求到同一资源：请求将转发到发布*

通过自动重取，您可以在一定程度上缓解这种情况。 自动失效后，大多数失效的页面仍以物理方式存储在调度程序上。 他们只被认 _为是陈腐_ 。 _“自动重取_ ”表示您仍然会在几秒钟内为这些陈旧页面提供服务，同时 _向发布系统_ 启动一个请求以重新获取过时内容：

![在后台重取时交付陈旧内容](assets/chapter-1/fetching-background.png)

*在后台重取时交付陈旧内容*

<br> 

要启用重取，您必须告诉调度程序在自动失效后要重取哪些资源。 请记住，您激活的任何页面也会自动使所有其他页面失效，包括常用页面。

重新获取实际上意味着在每个(!) invalidation请求您要重新获取最受欢迎的、最受欢迎的。

这是通过将资源URL（实际URL，而不仅仅是路径）列表在无效请求主体中实现的：

```
POST /dispatcher/invalidate.cache HTTP/1.1

CQ-Action: Activate
CQ-Handle: /content/my-brand/home/path/to/some/resource
Content-Type: Text/Plain
Content-Length: 207

/content/my-brand/home.html
/content/my-brand/campaigns/landing-page-1.html
/content/my-brand/campaigns/landing-page-2.html
/content/my-brand/products/product-1.html
/content/my-brand/products/product-2.html
```

当调度程序看到此类请求时，它将像往常一样触发自动失效，并立即排队请求以从发布系统重新获取新内容。

与现在一样，我们使用的是请求主体，我们还需要根据HTTP标准设置内容类型和内容长度。

调度程序还根据URL在内部进行标记，这样它就知道即使这些资源被自动失效视为无效资源，也可以直接传送这些资源。

所有列出的URL都是逐个请求的。 因此，您无需担心在发布系统上创建过高负载。 但您也不希望在该列表中放置过多URL。 最后，队列最终需要在有界时间内进行处理，才能在太长的时间内不提供过时的内容。 只需包括您10个最常访问的页面。

如果查看Dispatcher的缓存目录，您将看到带有时间戳的临时文件。 这些是当前正在后台加载的文件。

**引用**

[helpx.adobe.com —— 使来自AEM的缓存页面失效](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html)

### 屏蔽发布系统

调度程序通过保护发布系统免受仅用于维护目的的请求的影响，提供了一些额外的安全性。 例如，您不希望向公众 `/crx/de` 公 `/system/console` 开您或URL。

在系统中安装Web应用程序防火墙(WAF)并不有害。 但这会为您的预算增加大量资金，并非所有项目都承受得起，也不要忘记，它们能够运营和维护一个WAF。

我们经常看到的是Dispatcher配置中的一组Apache重写规则，可防止访问更易受攻击的资源。

但您也可以考虑另一种方法：

根据调度程序配置，调度程序模块绑定到特定目录：

```
<Directory />
  SetHandler dispatcher-handler
  …
</Directory>
```

但是，当您需要在之后进行筛选时，为什么要将处理函数绑定到整个docroot?

您首先可以缩小处理程序的绑定范围。 `SetHandler` 只需将处理函数绑定到目录，就可以将该处理函数绑定到URL或URL模式：

```
<LocationMatch "^(/content|/etc/design|/dispatcher/invalidate.cache)/.\*">
  SetHandler dispatcher-handler
</LocationMatch>

<LocationMatch "^/dispatcher/invalidate.cache">
  SetHandler dispatcher-handler
</LocationMatch>

…
```

如果这样做，请不要忘记始终将调度程序处理程序绑定到调度程序的失效URL —— 否则您将无法将失效请求从AEM发送到调度程序。

另一个将调度程序用作过滤器的替代方法是在 `dispatcher.any`

```
/filter {
  /0001  { /glob "\*" /type "deny" }
  /0002  { /type "allow"  /url "/content\*"  }
```

我们不是强制使用一个指令，而是建议对所有指令进行适当组合。

但我们建议您考虑尽可能早地在链中缩小URL空间，并尽可能以最简单的方式缩小。 请记住，这些技术并非高度敏感网站上的WAF的替代品。 一些人称这些技术为“穷人的防火墙”—这是有原因的。

**引用**

[apache.org-sethandler指令](https://httpd.apache.org/docs/2.4/mod/core.html#sethandler)

[helpx.adobe.com —— 配置对内容过滤器的访问](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html#ConfiguringAccesstoContentfilter)

### 使用正则表达式和全局进行过滤

在早期，您只能使用“globs”-简单的占位符来定义调度程序配置中的过滤器。

幸运的是，在Dispatcher的较新版本中，这一点发生了改变。 现在，您还可以使用POSIX常规表达式，并访问请求的各个部分以定义筛选器。 对于刚刚开始使用调度程序的人而言，这可能是理所当然的。 但如果你习惯只有球门，那就有点出人意料，很容易被忽视。 除了globs和regexes的语法之外，它们的语法也过于相似。 让我们比较两个相同的版本：

```
# Version A

/filter {
  /0001  { /glob "\*" /type "deny" }
  /0002  { /type "allow"  /url "/content\*"  }

# Version B

/filter {
  /0001  { /glob "\*" /type "deny" }
  /0002  { /type "allow"  /url '/content.\*'  }
```

你看到区别了吗？

版本B使用单引 `'` 号标记常规 _表达式模式_。 “任何字符”是使用表示的 `.*`。

_与之相比_，格式变换使用多次引 `"` 号，您只能使用简单的占位符，如 `*`果。

如果您知道这一区别，那将无关紧要——但如果不知道，您可以轻松地将引号混为一谈，然后花一个阳光明媚的下午调试配置。 现在有人警告你。

“我在配置 `'/url'` 中识别……但您可能会问 `'/glob'` 的过滤器中包含什么？

该指令表示整个请求字符串，包括方法和路径。 它可以代表

`"GET /content/foo/bar.html HTTP/1.1"`

这是您的模式将与之比较的字符串。 初学者往往会忘记第一部分， `method` 即GET、POST..... 所以，一个模式

`/0002  { /glob "/content/\*" /type "allow" }`

将始终失败，因为“/content”与“GET...”不匹配 请求。

所以当你想用Globs时，

`/0002  { /glob "GET /content/\*" /type "allow" }`

是正确的。

对于初始拒绝规则，如

`/0001  { /glob "\*" /type "deny" }`

这很好。 但是，对于后续的允许，使用请求的各个部分会更好、更清晰、更具表现力、更安全：

```
/method
/url
/path
/selector
/extension
/suffix
```

如此：

```
/005  {

  /type "allow"
  /method "GET"
  /extension '(css|gif|ico|js|png|swf|jpe?g)' }
```

请注意，您可以在规则中混合正则表达式和全局表达式。

在每个定义前面，最后一 `/005` 个词是“行号”,

他们毫无意义！ 可以为规则选择任意分母。 使用数字并不需要花太多的精力去考虑一个方案，但要记住，顺序很重要。

如果您有数百条这样的规则：

```
/001
/002
/003
…
/100
…
```

您希望在/001和/002之间插入一个，后续数字会出现什么情况？ 你在增加他们的数量吗？ 你在插入中间号码吗？

```
/001
/001a
/002
/003
…
/100
…
```

或者，如果您更改/003和/001的顺序，您会更改其名称和身份，或者您

```
/003
/002
/001
…
/100
…
```

编号，但从长远看，它乍看上去似乎是一个简单的选择。 老实说，选择数字作为标识符是一种糟糕的编程方式。

我们想提出一种不同的方法：您很可能不会为每个筛选器规则提供有意义的标识符。 但它们可能有更大的用途，因此它们可以按照目的以某种方式进行分组。 例如，“基本设置”、“应用程序特定例外”、“全局例外”和“安全性”。

然后，您可以相应地命名规则并对其进行分组，并为配置的读者（您的亲爱同事）提供文件中的某些方向：

```plain
  # basic setup:

  /filter {

    # basic setup

    /basic_01  { /glob "\*"             /type "deny"  }
    /basic_02  { /glob "/content/\*"    /type "allow" }
    /basic_03  { /glob "/etc/design/\*" /type "allow" }

    /basic_04  { /extension '(json|xml)'  /type "deny"  }
    …


    # login

    /login_01 { /glob "/api/myapp/login/\*" /type "allow" }
    /login_02 { … }

    # global exceptions

    /global_01 { /method "POST" /url '.\*contact-form.html' }
```


您很可能会向其中一个组添加新规则，甚至可能会创建新组。 在这种情况下，要重命名／重新编号的项目数限于该组。

>[!WARNING]
>
>更复杂的设置将过滤规则拆分为多个文件，这些文件由主配置文 `dispatcher.any` 件包含。 但是，新文件不引入新命名空间。 因此，如果一个文件中有规则“001”，另一个文件有规则“001”，您将收到错误。 更有理由用语义上的强名来命名。

**引用**

[helpx.adobe.com —— 全局属性的设计模式](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html#DesigningPatternsforglobProperties)

### 协议规范

最后的小费不是真正的小费，但我们觉得与您分享这个值得。

AEM和Dispatcher在大多数情况下均可开箱即用。 因此，您找不到关于失效协议的全面的调度程序协议规范，以在顶部构建您自己的应用程序。 这些信息是公开的，但分散在许多资源上。

我们尽量在这里填补空白。 无效请求的外观如下：

```
POST /dispatcher/invalidate.cache HTTP/1.1
CQ-Action: <action>
CQ-Handle: <path-pattern>
[CQ-Action-Scope]
[Content-Type: Text/Plain]
[Content-Length: <bytes in request body>]

<newline>

<refetch-url-1>
<refetch-url-2>

…

<refetch-url-n>
```

`POST /dispatcher/invalidate.cache HTTP/1.1` -第一行是调度程序控件端点的URL，您很可能不会更改它。

`CQ-Action: <action>` -应该发生什么。 `<action>` 是：

* `Activate:` 删除 `/path-pattern.*`
* `Deactive:` 删除 `/path-pattern.*`和删除 `/path-pattern/*`
* `Delete:`   删除 `/path-pattern.*`和删除 
`/path-pattern/*`
* `Test:`   返回“ok”，但不执行任何操作

`CQ-Handle: <path-pattern>` -要失效的内容资源路径。 注意 `<path-pattern>` ，实际上是“路径”，而不是“模式”。

`CQ-Action-Scope: ResourceOnly` -可选：如果设置了此标题，则 `.stat` 不会触及文件。

```
[Content-Type: Text/Plain]
[Content-Length: <bytes in request body>]
```

如果定义自动重取URL的列表，请设置这些标题。 `<bytes in request body>` 是HTTP正文中的字符数

`<newline>` -如果您有请求主体，则必须用空行将其与标题分隔开。

```
<refetch-url-1>
<refetch-url-2>
…
<refetch-url-n>
```

列表在失效后要立即重新获取的URL。

## 其他资源

Dispatcher缓存的简介： [https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher.html](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher.html)

更多优化提示与技巧： [https://helpx.adobe.com/experience-manager/kb/optimizing-the-dispatcher-cache.html#use-ttls](https://helpx.adobe.com/experience-manager/kb/optimizing-the-dispatcher-cache.html#use-ttls)

包含所有指令的调度程序文档已说明： [https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html](https://helpx.adobe.com/cn/experience-manager/dispatcher/using/dispatcher-configuration.html)

一些常见问题： [https://helpx.adobe.com/experience-manager/using/dispatcher-faq.html](https://helpx.adobe.com/experience-manager/using/dispatcher-faq.html)

录制有关Dispatcher优化的网络研讨会——强烈建议： [https://my.adobeconnect.com/p7th2gf8k43?proto=true](https://my.adobeconnect.com/p7th2gf8k43?proto=true)

2018年在波茨坦举行的题为“内容失效的未被充分重视的力量”、“adaptTo()”的会 [议https://adapt.to/2018/en/schedule/the-underappreciated-power-of-content-invalidation.html](https://adapt.to/2018/en/schedule/the-underappreciated-power-of-content-invalidation.html)

来自AEM的已缓存页面失效： [https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html)

## 下一步

* [2 —— 基础结构模式](chapter-2.md)
