---
title: 开发资产计算工作人员
description: 资产计算工作线程是资产计算项目的核心，它提供可对资产执行或协调工作以创建新演绎版的自定义功能。
feature: asset-compute
topics: renditions, development
version: cloud-service
activity: develop
audience: developer
doc-type: tutorial
kt: 6282
thumbnail: KT-6282.jpg
translation-type: tm+mt
source-git-commit: 6f5df098e2e68a78efc908c054f9d07fcf22a372
workflow-type: tm+mt
source-wordcount: '1418'
ht-degree: 0%

---


# 开发资产计算工作人员

资产计算工作线程是资产计算项目的核心，它提供对资产执行或协调工作以创建新再现的自定义功能。

资产计算项目会自动生成一个简单的工作程序，该程序会将资产的原始二进制文件复制到指定演绎版中，而不进行任何转换。 在本教程中，我们将修改此工作人员，制作更有趣的再现，以说明资产计算工作人员的强大功能。

我们将创建一个资产计算工作人员，该人员将生成一个新的水平图像演绎版，该格式副本在资产版本模糊的情况下，将空白空间覆盖在资产演绎版的左侧和右侧。 最终再现的宽度、高度和模糊将进行参数化。

## 资产计算工作器调用的逻辑流

资产计算工作者在函数中实施资产计算SDK工作 `renditionCallback(...)` 者API合同，从概念上讲：

+ __输入：__ AEM资产的原始二进制和处理用户档案参数
+ __输出：__ 一个或多个要添加到AEM资产的演绎版

![资产计算工作人员逻辑流](./assets/worker/logical-flow.png)

1. AEM作者服务调用资产计算工作 __人员，提供资产的(1a__ )原始二进制`source` （参数）和 __(1b)处理用户档案__ （参数）中定义的任何`rendition.instructions` 参数。
1. 资产计算SDK安排自定义资产计算元数据工作器的 `renditionCallback(...)` 函数的执行，根据资产的原始二进制(1a) __和任何参数(1b)生__ 成新的二进制再 __现__。

   + 在本教程中，再现是“正在创建”的，这意味着工作者组成再现，但源二进制文件也可以发送到其他Web服务API以生成再现。

1. 资产计算工作者会将新再现的二进制数据保存到 `rendition.path`。
1. 写入的二进制数 `rendition.path` 据通过Asset Compute SDK传输到AEM Author Service __，并以(4a)文本格式副本和(__ 4b) ____ （持久存储到资产的元数据节点）形式公开。

上图阐述了面向资产计算开发人员的问题和资产计算工作人员调用的逻辑流程。 出于好奇，可 [以获取资产计算执行的内部详细](https://docs.adobe.com/content/help/en/asset-compute/using/extend/custom-application-internals.html) ，但只能依赖公共资产计算SDK API合同。

## 工人剖析

所有资产计算工作人员遵循相同的基本结构和输入／输出合同。

```javascript
'use strict';

// Any npm module imports used by the worker
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

/**
Exports the worker implemented by a custom rendition callback function, which parametrizes the input/output contract for the worker.
 + `source` represents the asset's original binary used as the input for the worker.
 + `rendition` represents the worker's output, which is the creation of a new asset rendition.
 + `params` are optional parameters, which map to additional key/value pairs, including a sub `auth` object that contains Adobe I/O access credentials.
**/
exports.main = worker(async (source, rendition, params) => {
    // Perform any necessary source (input) checks
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        // Throw appropriate errors whenever an erring condition is met
        throw new SourceCorruptError('source file is empty');
    }

    // Access any custom parameters provided via the Processing Profile configuration
    let param1 = rendition.instructions.exampleParam;

    /** 
    Perform all work needed to transform the source into the rendition.
    
    The source data can be accessed:
        + In the worker via a file available at `source.path`
        + Or via a presigned GET URL at `source.url`
    **/
    if (success) {
        // A successful worker must write some data back to `renditions.path`. 
        // This example performs a trivial 1:1 copy of the source binary to the rendition
        await fs.copyFile(source.path, rendition.path);
    } else {
        // Upon failure an Asset Compute Error (exported by @adobe/asset-compute-commons) should be thrown.
        throw new GenericError("An error occurred!", "example-worker");
    }
});

/**
Optionally create helper classes or functions the worker's rendition callback function invokes to help organize code.

Code shared across workers, or to complex to be managed in a single file, can be broken out across supporting JavaScript files in the project and imported normally into the worker. 
**/
function customHelperFunctions() { ... }
```

## 打开worker index.js

![自动生成的index.js](./assets/worker/autogenerated-index-js.png)

1. 确保资产计算项目以VS代码打开
1. 导览至文件 `/actions/worker` 夹
1. Open the `index.js` file

这是我们将在本教程中修改的工作JavaScript文件。

## 安装和导入支持npm模块

作为基于Node.js的资产计算项目，它可以从强大的npm模块 [生态系统中受益](https://npmjs.com)。 要利用npm模块，我们必须先将它们安装到我们的Asset Compute项目中。

在此工作者中，我们利 [用jimp](https://www.npmjs.com/package/jimp) 直接在Node.js代码中创建和操作再现图像。

>[!WARNING]
>
>资产计算并不支持用于资产处理的所有npm模块。 npm模块，它们依赖于其他应用程序（如ImageMagick或操作系统相关库）的现有。 最好限制仅使用JavaScript npm模块。

1. 打开资产计算项目根目录中的命令行(可以在VS代码中通过“终端”>“新建终 __端”执行此操作__)并执行命令：

   ```
   $ npm install jimp
   ```

1. 将模 `jimp` 块导入工作代码，以便通过JavaScript对象 `Jimp` 使用它。
更新 `require` 工作器顶部的指令，以 `index.js` 从模 `Jimp` 块导入对 `jimp` 象：

   ```javascript
   'use strict';
   
   const { Jimp } = require('jimp');
   const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
   const fs = require('fs').promises;
   
   exports.main = worker(async (source, rendition, params) => {
       // Check handle a corrupt input source
       const stats = await fs.stat(source.path);
       if (stats.size === 0) {
           throw new SourceCorruptError('source file is empty');
       }
   
       // Do work here
   });
   ```

## 读取参数

资产计算工作线程可以读取参数，这些参数可以通过在AEM中定义为Cloud Service作者服务的处理用户档案传入。 参数通过对象传递到工作 `rendition.instructions` 器。

可以通过访问工作 `rendition.instructions.<parameterName>` 代码来读取。

在此，我们将阅读可配置再现的内 `SIZE`容， `BRIGHTNESS` 并提 `CONTRAST`供默认值(如果尚未通过处理用户档案提供)。 请注意， `renditions.instructions` 从AEM作为Cloud Service处理用户档案调用时，将作为字符串传入，因此请确保将它们转换为工作代码中的正确数据类型。

```javascript
'use strict';

const { Jimp } = require('jimp');
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    // Processing Profiles pass in instructions as Strings, so make sure to parse to correct data types
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    // Do work here
}
```

## 引发错误{#errors}

资产计算工作线程可能会遇到导致错误的情况。 Adobe资产计算SDK提 [供了一套预定义错误](https://github.com/adobe/asset-compute-commons#asset-compute-errors) ，在遇到此类情况时可能会引发这些错误。 如果未应用特定错误类型，则可 `GenericError` 以使用，或可以定义特 `ClientErrors` 定的自定义。

在开始处理再现之前，请检查以确保此工作器的上下文中所有参数都有效且受支持：

+ 确保、和的再现 `SIZE`说明 `CONTRAST`参数 `BRIGHTNESS` 有效。 否则，抛出自定义错误 `RenditionInstructionsError`。
   + 扩展 `RenditionInstructionsError` 的自定 `ClientError` 义类在此文件底部定义。 在为工作者编写测试时，使用特定的自 [定义错误](../test-debug/test.md) 很有用。

```javascript
'use strict';

const { Jimp } = require('jimp');
// Import the Asset Compute SDK provided `ClientError` 
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        // Ensure size is within allowable bounds
        throw new RenditionInstructionsError("'size' must be between 10 and 1,0000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Do work here
}

// Create a new ClientError to handle invalid rendition.instructions values
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        // Provide a:
        // + message: describing the nature of this erring condition
        // + name: the name of the error; usually same as class name
        // + reason: a short, searchable, unique error token that identifies this error
        super(message, "RenditionInstructionsError", "rendition_instructions_error");

        // Capture the strack trace
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## 创建再现

读取、清理和验证参数后，将编写代码以生成再现。 生成再现的伪代码如下所示：

1. 以通过参 `renditionImage` 数指定的平方尺寸创建新画 `size` 布。
1. 从源资 `image` 产的二进制文件创建对象
1. 使用 __Jimp__ 库转换图像：
   + 将原始图像裁剪到居中的正方形
   + 从“方形”图像的中心剪切一个圆
   + 缩放以适合由参数值定义 `SIZE` 的尺寸
   + 根据参数值调 `CONTRAST` 整对比度
   + 根据参数值调 `BRIGHTNESS` 整亮度
1. 将转换后 `image` 的内容放在具有透 `renditionImage` 明背景的中心
1. 编写合成内容 `renditionImage` , `rendition.path` 以将其保存回AEM作为资产演绎版。

此代码使用 [Jimp API](https://github.com/oliver-moran/jimp#jimp) ，执行这些图像转换。

资产计算工作人员必须同步完成工作， `rendition.path` 并且必须在工作人员完成之前完全写回 `renditionCallback` 到。 这要求异步函数调用使用运算符进行同步 `await` 调用。 如果您不熟悉JavaScript异步函数以及如何使它们以同步方式执行，请熟悉 [JavaScript的Await运算符](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)。

完成的工作 `index.js` 者应该如下：

```javascript
'use strict';

const Jimp = require('jimp');
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        throw new RenditionInstructionsError("'size' must be between 10 and 10,000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Create target rendition image of the target size with a transparent background (0x0)
    let renditionImage =  new Jimp(SIZE, SIZE, 0x0);

    // Read and perform transformations on the source binary image
    let image = await Jimp.read(source.path);

    // Crop a circle from the source asset, and then apply contrast and brightness using Jimp
    image.crop(
            image.bitmap.width < image.bitmap.height ? 0 : (image.bitmap.width - image.bitmap.height) / 2,
            image.bitmap.width < image.bitmap.height ? (image.bitmap.height - image.bitmap.width) / 2 : 0,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height
        )   
        .circle()
        .scaleToFit(SIZE, SIZE)
        .contrast(CONTRAST)
        .brightness(BRIGHTNESS);

    // Place the transformed image onto the transparent renditionImage to save as PNG
    renditionImage.composite(image, 0, 0)

    // Write the final transformed image to the asset's rendition
    renditionImage.write(rendition.path);
});

// Custom error used for renditions.instructions parameter checking
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        super(message, "RenditionInstructionsError", "rendition_instructions_error");
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## 运行工作器

由于工作代码已完成，并且之前已在manifest.yml中注 [册和配置](./manifest.md)，因此可以使用本地资产计算开发工具执行该代码以查看结果。

1. 从资产计算项目的根
1. 执行 `aio app run`
1. 等待资产计算开发工具在新窗口中打开
1. 在选 __择文件……下拉框中__ ，选择要处理的示例图像
   + 选择要用作源资产二进制文件的示例图像文件
   + 如果还不存在，请点按左 __侧的__ (+)，上传示例图 [像文件，然后刷](../assets/samples/sample-file.jpg) 新“开发工具”浏览器窗口
1. 作为 `"name": "rendition.png"` 此工作器进行更新以生成透明PNG。
   + 请注意，此“name”参数仅用于开发工具，不应依赖。

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png"
           }
       ]
   }
   ```
1. 点按 __运行__ ，然后等待再现生成
1. 演绎 __版部分__ ，将生成的演绎版预览。 点按演绎版预览以下载完整的演绎版

   ![默认PNG再现](./assets/worker/default-rendition.png)

### 使用参数运行工作器

通过处理用户档案配置传入的参数可在资产计算开发工具中模拟，方法是在演绎版参数JSON中将其作为键／值对提供。

>[!WARNING]
>
>在本地开发过程中，当从AEM作为Cloud Service处理用户档案作为字符串传入时，可以使用各种数据类型传入值，因此，请确保根据需要分析正确的数据类型。
> 例如，Jimp的函 `crop(width, height)` 数要求其参数 `int`为&#39;s。如 `parseInt(rendition.instructions.size)` 果未解析为int，则对的调用将失 `jimp.crop(SIZE, SIZE)` 败，因为参数将不兼容“字符串”类型。

我们的代码接受以下参数：

+ `size` 定义演绎版的大小（高度和宽度为整数）
+ `contrast` 定义对比度调整，必须介于-1和1之间，作为浮点
+ `brightness`  定义亮度调整，必须介于-1和1之间，作为浮点

在工作人员中通过以下方式 `index.js` 阅读：

+ `const SIZE = parseInt(rendition.instructions.size) || 800`
+ `const CONTRAST = parseFloat(rendition.instructions.contrast) || 0`
+ `const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0`

1. 更新再现参数以自定义大小、对比度和亮度。

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png",
               "size": "450",
               "contrast": "0.30",
               "brightness": "0.15"
           }
       ]
   }
   ```

1. 再次点 __击“运行__ ”
1. 点按演绎版预览以下载和查看生成的演绎版。 请注意其尺寸以及与默认再现相比对比度和亮度的更改方式。

   ![参数化PNG再现](./assets/worker/parameterized-rendition.png)

1. 将其他图像上传到 __源文件__ ，然后尝试使用不同的参数针对它们运行工作器！

## Github上的Worker index.js

最后一 `index.js` 节在Github上提供，网址为：

+ [aem-guides-wknd-asset-compute/actions/worker/index.js](https://github.com/adobe/aem-guides-wknd-asset-compute/blob/master/actions/worker/index.js)

## 疑难解答

+ [返回部分绘制／损坏的再现](../troubleshooting.md#rendition-returned-partially-drawn-or-corrupt)
