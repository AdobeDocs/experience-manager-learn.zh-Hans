---
title: 开发Asset compute工作人员
description: asset compute工作程序是Asset compute项目的核心，它提供对资产执行或协调工作以创建新呈现的自定义功能。
feature: Asset Compute Microservices
topics: renditions, development
version: Cloud Service
activity: develop
audience: developer
doc-type: tutorial
kt: 6282
thumbnail: KT-6282.jpg
topic: Integrations, Development
role: Developer
level: Intermediate, Experienced
exl-id: 7d51ec77-c785-4b89-b717-ff9060d8bda7
source-git-commit: b069d958bbcc40c0079e87d342db6c5e53055bc7
workflow-type: tm+mt
source-wordcount: '1416'
ht-degree: 0%

---

# 开发Asset compute工作人员

asset compute工作程序是Asset compute项目的核心，它提供了对资产执行或协调工作以创建新呈现的自定义功能。

asset compute项目会自动生成一个简单的工作程序，该工作程序会将资产的原始二进制文件复制到命名演绎版中，而不进行任何转换。 在本教程中，我们将修改此工作程序，以制作更有趣的演绎版，以说明Asset compute工作程序的强大功能。

我们将创建一个Asset compute工作程序，以生成新的水平图像呈现版本，该版本在资产呈现版本模糊的情况下，将资产呈现版本左侧和右侧的空白区域覆盖在其中。 最终呈现版本的宽度、高度和模糊已参数化。

## asset compute工作程序调用的逻辑流

asset compute工作人员实施Asset computeSDK工作人员API合同(位于 `renditionCallback(...)` 函数，从概念上讲：

+ __输入：__ AEM资产的原始二进制文件和处理配置文件参数
+ __输出：__ 要添加到AEM资产的一个或多个演绎版

![asset compute工作逻辑流](./assets/worker/logical-flow.png)

1. AEM创作服务会调用Asset compute工作程序，并提供资产的 __(1a)__ 原始二进制文件(`source` 参数)和 __(1b)__ 处理配置文件中定义的任何参数(`rendition.instructions` 参数)。
1. asset computeSDK协调自定义Asset compute元数据工作程序的执行 `renditionCallback(...)` 函数，根据资产的原始二进制演绎版生成新的二进制演绎版 __(1a)__ 和任何参数 __(1b)__.

   + 在本教程中，演绎版是“正在创建”的，这意味着工作程序会组成演绎版，但源二进制文件也可以发送到其他Web服务API以生成演绎版。

1. asset compute工作程序将新再现的二进制数据保存到 `rendition.path`.
1. 写入的二进制数据 `rendition.path` 通过Asset computeSDK传输到AEM创作服务，并作为 __(4a)__ 文本呈现和 __(4b)__ 保留到资产的元数据节点。

上图阐述了面向Asset compute开发人员的问题以及Asset compute工作程序调用的逻辑流程。 为了好奇， [asset compute执行的内部详细信息](https://experienceleague.adobe.com/docs/asset-compute/using/extend/custom-application-internals.html) 可用，但只能依赖公共Asset computeSDK API合同。

## 工人解剖学

所有Asset compute工人都遵循相同的基本结构和投入/产出合同。

```javascript
'use strict';

// Any npm module imports used by the worker
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

/**
Exports the worker implemented by a custom rendition callback function, which parametrizes the input/output contract for the worker.
 + `source` represents the asset's original binary used as the input for the worker.
 + `rendition` represents the worker's output, which is the creation of a new asset rendition.
 + `params` are optional parameters, which map to additional key/value pairs, including a sub `auth` object that contains Adobe I/O access credentials.
**/
exports.main = worker(async (source, rendition, params) => {
    // Perform any necessary source (input) checks
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        // Throw appropriate errors whenever an erring condition is met
        throw new SourceCorruptError('source file is empty');
    }

    // Access any custom parameters provided via the Processing Profile configuration
    let param1 = rendition.instructions.exampleParam;

    /** 
    Perform all work needed to transform the source into the rendition.
    
    The source data can be accessed:
        + In the worker via a file available at `source.path`
        + Or via a presigned GET URL at `source.url`
    **/
    if (success) {
        // A successful worker must write some data back to `renditions.path`. 
        // This example performs a trivial 1:1 copy of the source binary to the rendition
        await fs.copyFile(source.path, rendition.path);
    } else {
        // Upon failure an Asset Compute Error (exported by @adobe/asset-compute-commons) should be thrown.
        throw new GenericError("An error occurred!", "example-worker");
    }
});

/**
Optionally create helper classes or functions the worker's rendition callback function invokes to help organize code.

Code shared across workers, or to complex to be managed in a single file, can be broken out across supporting JavaScript files in the project and imported normally into the worker. 
**/
function customHelperFunctions() { ... }
```

## 打开工作index.js

![自动生成的index.js](./assets/worker/autogenerated-index-js.png)

1. 确保Asset compute项目在VS代码中处于打开状态
1. 导航到 `/actions/worker` 文件夹
1. 打开 `index.js` 文件

这是我们将在本教程中修改的工作JavaScript文件。

## 安装和导入支持npm模块

asset compute项目基于Node.js，能够从 [npm模块生态系统](https://npmjs.com). 要利用npm模块，我们必须先将它们安装到我们的Asset compute项目中。

在这位员工中，我们利用 [jimp](https://www.npmjs.com/package/jimp) 要直接在Node.js代码中创建和操作演绎版图像，请执行以下操作：

>[!WARNING]
>
>并非所有用于资产处理的npm模块都受Asset compute支持。 不支持依赖存在ImageMagick或其他依赖于操作系统的库等应用程序的npm模块。 最好限制仅使用JavaScript npm模块。

1. 在Asset compute项目的根中打开命令行(可在VS代码中通过 __终端>新建终端__)并执行命令：

   ```
   $ npm install jimp
   ```

1. 导入 `jimp` 模块输入到工作代码中，以便通过 `Jimp` JavaScript对象。
更新 `require` 工人最高的指示 `index.js` 导入 `Jimp` 对象 `jimp` 模块：

   ```javascript
   'use strict';
   
   const Jimp = require('jimp');
   const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
   const fs = require('fs').promises;
   
   exports.main = worker(async (source, rendition, params) => {
       // Check handle a corrupt input source
       const stats = await fs.stat(source.path);
       if (stats.size === 0) {
           throw new SourceCorruptError('source file is empty');
       }
   
       // Do work here
   });
   ```

## 读取参数

asset compute工作者可以读取参数，这些参数可以通过AEMas a Cloud Service创作服务中定义的处理用户档案传入。 这些参数将通过 `rendition.instructions` 对象。

可以通过访问 `rendition.instructions.<parameterName>` 在工作代码中。

我们将在此阅读可配置呈现版本的 `SIZE`, `BRIGHTNESS` 和 `CONTRAST`，如果尚未通过处理配置文件提供任何值，则提供默认值。 请注意 `renditions.instructions` 在从AEMas a Cloud Service处理配置文件调用时，将作为字符串传递，因此请确保将它们转换为工作代码中的正确数据类型。

```javascript
'use strict';

const Jimp = require('jimp');
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    // Processing Profiles pass in instructions as Strings, so make sure to parse to correct data types
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    // Do work here
}
```

## 引发错误{#errors}

asset compute工作者可能会遇到导致错误的情况。 AdobeAsset computeSDK提供 [一套预定义的错误](https://github.com/adobe/asset-compute-commons#asset-compute-errors) 在遇到此类情况时，会引发该事件。 如果未应用特定错误类型，则 `GenericError` 可使用，或特定自定义 `ClientErrors` 可定义。

在开始处理演绎版之前，请检查以确保此工作程序的上下文中所有参数都有效和支持：

+ 确保的格式副本指令参数 `SIZE`, `CONTRAST`和 `BRIGHTNESS` 有效。 如果没有，则引发自定义错误 `RenditionInstructionsError`.
   + 自定义 `RenditionInstructionsError` 扩展类 `ClientError` 在此文件的底部定义。 使用特定的自定义错误在 [编写测试](../test-debug/test.md) 为工人。

```javascript
'use strict';

const Jimp = require('jimp');
// Import the Asset Compute SDK provided `ClientError` 
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        // Ensure size is within allowable bounds
        throw new RenditionInstructionsError("'size' must be between 10 and 1,0000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Do work here
}

// Create a new ClientError to handle invalid rendition.instructions values
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        // Provide a:
        // + message: describing the nature of this erring condition
        // + name: the name of the error; usually same as class name
        // + reason: a short, searchable, unique error token that identifies this error
        super(message, "RenditionInstructionsError", "rendition_instructions_error");

        // Capture the strack trace
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## 创建演绎版

通过读取、清理和验证参数，可编写代码以生成演绎版。 生成演绎版的伪代码如下所示：

1. 新建 `renditionImage` 画布，以通过 `size` 参数。
1. 创建 `image` 源资产的二进制文件中的对象
1. 使用 __Jimp__ 转换图像的库：
   + 将原始图像裁剪到居中的正方形
   + 从“方形”图像的中心剪切圆
   + 根据 `SIZE` 参数值
   + 根据 `CONTRAST` 参数值
   + 根据 `BRIGHTNESS` 参数值
1. 将转换后的 `image` 进入 `renditionImage` 具有透明背景
1. 写作内容， `renditionImage` to `rendition.path` 以便可以另存为AEM资产演绎版。

此代码使用 [Jimp API](https://github.com/oliver-moran/jimp#jimp) 执行这些图像转换。

asset compute工人必须同步完成工作， `rendition.path` 必须在员工的 `renditionCallback` 结束。 这要求异步函数调用必须使用 `await` 运算符。 如果您不熟悉JavaScript异步函数以及如何以同步方式执行这些函数，请熟悉 [JavaScript的await运算符](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await).

已完成的工作程序 `index.js` 应该如下所示：

```javascript
'use strict';

const Jimp = require('jimp');
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read/parse and validate parameters
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        throw new RenditionInstructionsError("'size' must be between 10 and 1,0000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Create target rendition image 
    let renditionImage =  new Jimp(SIZE, SIZE, 0x0);

    // Read and perform transformations on the source binary image
    let image = await Jimp.read(source.path);

    // Crop a circle from the source asset, and then apply contrast and brightness
    image.crop(
            image.bitmap.width < image.bitmap.height ? 0 : (image.bitmap.width - image.bitmap.height) / 2,
            image.bitmap.width < image.bitmap.height ? (image.bitmap.height - image.bitmap.width) / 2 : 0,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height
        )   
        .circle()
        .scaleToFit(SIZE, SIZE)
        .contrast(CONTRAST)
        .brightness(BRIGHTNESS);

    // Place the transformed image onto the transparent renditionImage to save as PNG
    renditionImage.composite(image, 0, 0)

    // Write the final transformed image to the asset's rendition
    await renditionImage.writeAsync(rendition.path);
});

// Custom error used for renditions.instructions parameter checking
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        super(message, "RenditionInstructionsError", "rendition_instructions_error");
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## 运行工作程序

现在，工作代码已完成，并且之前已在 [manifest.yml](./manifest.md)，则可以使用本地Asset compute开发工具执行该工具以查看结果。

1. 从Asset compute项目的根
1. 执行 `aio app run`
1. 等待Asset compute开发工具在新窗口中打开
1. 在 __选择文件……__ 下拉框中，选择要处理的样例图像
   + 选择要用作源资产二进制文件的示例图像文件
   + 如果尚不存在，请点按 __(+)__ 向左，然后上传 [样本图像](../assets/samples/sample-file.jpg) ，然后刷新“开发工具”浏览器窗口
1. 更新 `"name": "rendition.png"` 作为此工作程序生成透明PNG。
   + 请注意，此“name”参数仅用于开发工具，不应依赖此参数。

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png"
           }
       ]
   }
   ```

1. 点按 __运行__ 并等待演绎版生成
1. 的 __演绎版__ 部分预览生成的呈现版本。 点按演绎版预览以下载完整演绎版

   ![默认PNG演绎版](./assets/worker/default-rendition.png)

### 使用参数运行工作程序

通过处理配置文件配置传入的参数，可以在Asset compute开发工具中通过在呈现参数JSON中提供作为键/值对来模拟这些参数。

>[!WARNING]
>
>在本地开发期间，当值作为字符串从AEM作为Cloud Service处理配置文件传入时，可以使用各种数据类型传入，因此请确保在需要时分析正确的数据类型。
> 例如，Jimp的 `crop(width, height)` 函数要求其参数 `int`s.如果 `parseInt(rendition.instructions.size)` 将不解析为int，然后对的调用 `jimp.crop(SIZE, SIZE)` 失败，因为参数是不兼容的“字符串”类型。

我们的代码接受以下参数：

+ `size` 定义演绎版的大小（高度和宽度作为整数）
+ `contrast` 定义对比度调整，必须介于–1和1之间，为浮点
+ `brightness`  定义亮度调整，必须介于–1和1之间，为浮点

这些内容在工作人员中读取 `index.js` 通过：

+ `const SIZE = parseInt(rendition.instructions.size) || 800`
+ `const CONTRAST = parseFloat(rendition.instructions.contrast) || 0`
+ `const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0`

1. 更新演绎版参数以自定义大小、对比度和亮度。

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png",
               "size": "450",
               "contrast": "0.30",
               "brightness": "0.15"
           }
       ]
   }
   ```

1. 点按 __运行__ 再次
1. 点按演绎版预览以下载并查看生成的演绎版。 请注意其尺寸以及与默认呈现版本相比对比度和亮度的更改方式。

   ![参数化PNG呈现](./assets/worker/parameterized-rendition.png)

1. 将其他图像上传到 __源文件__ 下拉列表，然后尝试使用不同的参数针对它们运行工作程序！

## Github上的Worker index.js

最后 `index.js` 可在Github上获取，网址为：

+ [aem-guides-wknd-asset-compute/actions/worker/index.js](https://github.com/adobe/aem-guides-wknd-asset-compute/blob/master/actions/worker/index.js)

## 疑难解答

+ [返回部分绘制/损坏的演绎版](../troubleshooting.md#rendition-returned-partially-drawn-or-corrupt)
